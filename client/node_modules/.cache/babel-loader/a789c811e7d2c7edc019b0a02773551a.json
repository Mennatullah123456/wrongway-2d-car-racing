{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nrequire('./utils/index.js');\nvar GraphicsGeometry = require('./GraphicsGeometry.js');\nvar FillStyle = require('./styles/FillStyle.js');\nvar LineStyle = require('./styles/LineStyle.js');\nvar display = require('@pixi/display');\nvar _const = require('./const.js');\nvar QuadraticUtils = require('./utils/QuadraticUtils.js');\nvar BezierUtils = require('./utils/BezierUtils.js');\nvar ArcUtils = require('./utils/ArcUtils.js');\nvar temp = new Float32Array(3);\nvar DEFAULT_SHADERS = {};\nvar _Graphics = /*#__PURE__*/function (_display$Container) {\n  _inherits(_Graphics, _display$Container);\n  function _Graphics() {\n    var _this;\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    _classCallCheck(this, _Graphics);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_Graphics).call(this));\n    _this.shader = null;\n    _this.pluginName = \"batch\";\n    _this.currentPath = null;\n    _this.batches = [];\n    _this.batchTint = -1;\n    _this.batchDirty = -1;\n    _this.vertexData = null;\n    _this._fillStyle = new FillStyle.FillStyle();\n    _this._lineStyle = new LineStyle.LineStyle();\n    _this._matrix = null;\n    _this._holeMode = false;\n    _this.state = core.State.for2d();\n    _this._geometry = geometry || new GraphicsGeometry.GraphicsGeometry();\n    _this._geometry.refCount++;\n    _this._transformID = -1;\n    _this.tint = 16777215;\n    _this.blendMode = core.BLEND_MODES.NORMAL;\n    return _this;\n  }\n  _createClass(_Graphics, [{\n    key: \"clone\",\n    value: function clone() {\n      this.finishPoly();\n      return new _Graphics(this._geometry);\n    }\n  }, {\n    key: \"lineStyle\",\n    value: function lineStyle() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var alignment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n      var native = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      if (typeof options === \"number\") {\n        options = {\n          width: options,\n          color: color,\n          alpha: alpha,\n          alignment: alignment,\n          native: native\n        };\n      }\n      return this.lineTextureStyle(options);\n    }\n  }, {\n    key: \"lineTextureStyle\",\n    value: function lineTextureStyle(options) {\n      options = Object.assign({\n        width: 0,\n        texture: core.Texture.WHITE,\n        color: options?.texture ? 16777215 : 0,\n        alpha: 1,\n        matrix: null,\n        alignment: 0.5,\n        native: false,\n        cap: _const.LINE_CAP.BUTT,\n        join: _const.LINE_JOIN.MITER,\n        miterLimit: 10\n      }, options);\n      if (this.currentPath) {\n        this.startPoly();\n      }\n      var visible = options.width > 0 && options.alpha > 0;\n      if (!visible) {\n        this._lineStyle.reset();\n      } else {\n        if (options.matrix) {\n          options.matrix = options.matrix.clone();\n          options.matrix.invert();\n        }\n        Object.assign(this._lineStyle, {\n          visible: visible\n        }, options);\n      }\n      return this;\n    }\n  }, {\n    key: \"startPoly\",\n    value: function startPoly() {\n      if (this.currentPath) {\n        var points = this.currentPath.points;\n        var len = this.currentPath.points.length;\n        if (len > 2) {\n          this.drawShape(this.currentPath);\n          this.currentPath = new core.Polygon();\n          this.currentPath.closeStroke = false;\n          this.currentPath.points.push(points[len - 2], points[len - 1]);\n        }\n      } else {\n        this.currentPath = new core.Polygon();\n        this.currentPath.closeStroke = false;\n      }\n    }\n  }, {\n    key: \"finishPoly\",\n    value: function finishPoly() {\n      if (this.currentPath) {\n        if (this.currentPath.points.length > 2) {\n          this.drawShape(this.currentPath);\n          this.currentPath = null;\n        } else {\n          this.currentPath.points.length = 0;\n        }\n      }\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(x, y) {\n      this.startPoly();\n      this.currentPath.points[0] = x;\n      this.currentPath.points[1] = y;\n      return this;\n    }\n  }, {\n    key: \"lineTo\",\n    value: function lineTo(x, y) {\n      if (!this.currentPath) {\n        this.moveTo(0, 0);\n      }\n      var points = this.currentPath.points;\n      var fromX = points[points.length - 2];\n      var fromY = points[points.length - 1];\n      if (fromX !== x || fromY !== y) {\n        points.push(x, y);\n      }\n      return this;\n    }\n  }, {\n    key: \"_initCurve\",\n    value: function _initCurve() {\n      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (this.currentPath) {\n        if (this.currentPath.points.length === 0) {\n          this.currentPath.points = [x, y];\n        }\n      } else {\n        this.moveTo(x, y);\n      }\n    }\n  }, {\n    key: \"quadraticCurveTo\",\n    value: function quadraticCurveTo(cpX, cpY, toX, toY) {\n      this._initCurve();\n      var points = this.currentPath.points;\n      if (points.length === 0) {\n        this.moveTo(0, 0);\n      }\n      QuadraticUtils.QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n      return this;\n    }\n  }, {\n    key: \"bezierCurveTo\",\n    value: function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n      this._initCurve();\n      BezierUtils.BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n      return this;\n    }\n  }, {\n    key: \"arcTo\",\n    value: function arcTo(x1, y1, x2, y2, radius) {\n      this._initCurve(x1, y1);\n      var points = this.currentPath.points;\n      var result = ArcUtils.ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n      if (result) {\n        var cx = result.cx,\n          cy = result.cy,\n          radius2 = result.radius,\n          startAngle = result.startAngle,\n          endAngle = result.endAngle,\n          anticlockwise = result.anticlockwise;\n        this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);\n      }\n      return this;\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(cx, cy, radius, startAngle, endAngle) {\n      var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      if (startAngle === endAngle) {\n        return this;\n      }\n      if (!anticlockwise && endAngle <= startAngle) {\n        endAngle += core.PI_2;\n      } else if (anticlockwise && startAngle <= endAngle) {\n        startAngle += core.PI_2;\n      }\n      var sweep = endAngle - startAngle;\n      if (sweep === 0) {\n        return this;\n      }\n      var startX = cx + Math.cos(startAngle) * radius;\n      var startY = cy + Math.sin(startAngle) * radius;\n      var eps = this._geometry.closePointEps;\n      var points = this.currentPath ? this.currentPath.points : null;\n      if (points) {\n        var xDiff = Math.abs(points[points.length - 2] - startX);\n        var yDiff = Math.abs(points[points.length - 1] - startY);\n        if (xDiff < eps && yDiff < eps) {} else {\n          points.push(startX, startY);\n        }\n      } else {\n        this.moveTo(startX, startY);\n        points = this.currentPath.points;\n      }\n      ArcUtils.ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n      return this;\n    }\n  }, {\n    key: \"beginFill\",\n    value: function beginFill() {\n      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this.beginTextureFill({\n        texture: core.Texture.WHITE,\n        color: color,\n        alpha: alpha\n      });\n    }\n  }, {\n    key: \"beginTextureFill\",\n    value: function beginTextureFill(options) {\n      options = Object.assign({\n        texture: core.Texture.WHITE,\n        color: 16777215,\n        alpha: 1,\n        matrix: null\n      }, options);\n      if (this.currentPath) {\n        this.startPoly();\n      }\n      var visible = options.alpha > 0;\n      if (!visible) {\n        this._fillStyle.reset();\n      } else {\n        if (options.matrix) {\n          options.matrix = options.matrix.clone();\n          options.matrix.invert();\n        }\n        Object.assign(this._fillStyle, {\n          visible: visible\n        }, options);\n      }\n      return this;\n    }\n  }, {\n    key: \"endFill\",\n    value: function endFill() {\n      this.finishPoly();\n      this._fillStyle.reset();\n      return this;\n    }\n  }, {\n    key: \"drawRect\",\n    value: function drawRect(x, y, width, height) {\n      return this.drawShape(new core.Rectangle(x, y, width, height));\n    }\n  }, {\n    key: \"drawRoundedRect\",\n    value: function drawRoundedRect(x, y, width, height, radius) {\n      return this.drawShape(new core.RoundedRectangle(x, y, width, height, radius));\n    }\n  }, {\n    key: \"drawCircle\",\n    value: function drawCircle(x, y, radius) {\n      return this.drawShape(new core.Circle(x, y, radius));\n    }\n  }, {\n    key: \"drawEllipse\",\n    value: function drawEllipse(x, y, width, height) {\n      return this.drawShape(new core.Ellipse(x, y, width, height));\n    }\n  }, {\n    key: \"drawPolygon\",\n    value: function drawPolygon() {\n      var points;\n      var closeStroke = true;\n      for (var _len = arguments.length, path = new Array(_len), _key = 0; _key < _len; _key++) {\n        path[_key] = arguments[_key];\n      }\n      var poly = path[0];\n      if (poly.points) {\n        closeStroke = poly.closeStroke;\n        points = poly.points;\n      } else if (Array.isArray(path[0])) {\n        points = path[0];\n      } else {\n        points = path;\n      }\n      var shape = new core.Polygon(points);\n      shape.closeStroke = closeStroke;\n      this.drawShape(shape);\n      return this;\n    }\n  }, {\n    key: \"drawShape\",\n    value: function drawShape(shape) {\n      if (!this._holeMode) {\n        this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);\n      } else {\n        this._geometry.drawHole(shape, this._matrix);\n      }\n      return this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._geometry.clear();\n      this._lineStyle.reset();\n      this._fillStyle.reset();\n      this._boundsID++;\n      this._matrix = null;\n      this._holeMode = false;\n      this.currentPath = null;\n      return this;\n    }\n  }, {\n    key: \"isFastRect\",\n    value: function isFastRect() {\n      var data = this._geometry.graphicsData;\n      return data.length === 1 && data[0].shape.type === core.SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n    }\n  }, {\n    key: \"_render\",\n    value: function _render(renderer) {\n      this.finishPoly();\n      var geometry = this._geometry;\n      geometry.updateBatches();\n      if (geometry.batchable) {\n        if (this.batchDirty !== geometry.batchDirty) {\n          this._populateBatches();\n        }\n        this._renderBatched(renderer);\n      } else {\n        renderer.batch.flush();\n        this._renderDirect(renderer);\n      }\n    }\n  }, {\n    key: \"_populateBatches\",\n    value: function _populateBatches() {\n      var geometry = this._geometry;\n      var blendMode = this.blendMode;\n      var len = geometry.batches.length;\n      this.batchTint = -1;\n      this._transformID = -1;\n      this.batchDirty = geometry.batchDirty;\n      this.batches.length = len;\n      this.vertexData = new Float32Array(geometry.points);\n      for (var i = 0; i < len; i++) {\n        var gI = geometry.batches[i];\n        var color = gI.style.color;\n        var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n        var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n        var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);\n        var batch = {\n          vertexData: vertexData,\n          blendMode: blendMode,\n          indices: indices,\n          uvs: uvs,\n          _batchRGB: core.utils.hex2rgb(color),\n          _tintRGB: color,\n          _texture: gI.style.texture,\n          alpha: gI.style.alpha,\n          worldAlpha: 1\n        };\n        this.batches[i] = batch;\n      }\n    }\n  }, {\n    key: \"_renderBatched\",\n    value: function _renderBatched(renderer) {\n      if (!this.batches.length) {\n        return;\n      }\n      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n      this.calculateVertices();\n      this.calculateTints();\n      for (var i = 0, l = this.batches.length; i < l; i++) {\n        var batch = this.batches[i];\n        batch.worldAlpha = this.worldAlpha * batch.alpha;\n        renderer.plugins[this.pluginName].render(batch);\n      }\n    }\n  }, {\n    key: \"_renderDirect\",\n    value: function _renderDirect(renderer) {\n      var shader = this._resolveDirectShader(renderer);\n      var geometry = this._geometry;\n      var tint = this.tint;\n      var worldAlpha = this.worldAlpha;\n      var uniforms = shader.uniforms;\n      var drawCalls = geometry.drawCalls;\n      uniforms.translationMatrix = this.transform.worldTransform;\n      uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;\n      uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;\n      uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;\n      uniforms.tint[3] = worldAlpha;\n      renderer.shader.bind(shader);\n      renderer.geometry.bind(geometry, shader);\n      renderer.state.set(this.state);\n      for (var i = 0, l = drawCalls.length; i < l; i++) {\n        this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n      }\n    }\n  }, {\n    key: \"_renderDrawCallDirect\",\n    value: function _renderDrawCallDirect(renderer, drawCall) {\n      var texArray = drawCall.texArray,\n        type = drawCall.type,\n        size = drawCall.size,\n        start = drawCall.start;\n      var groupTextureCount = texArray.count;\n      for (var j = 0; j < groupTextureCount; j++) {\n        renderer.texture.bind(texArray.elements[j], j);\n      }\n      renderer.geometry.draw(type, size, start);\n    }\n  }, {\n    key: \"_resolveDirectShader\",\n    value: function _resolveDirectShader(renderer) {\n      var shader = this.shader;\n      var pluginName = this.pluginName;\n      if (!shader) {\n        if (!DEFAULT_SHADERS[pluginName]) {\n          var MAX_TEXTURES = renderer.plugins[pluginName].MAX_TEXTURES;\n          var sampleValues = new Int32Array(MAX_TEXTURES);\n          for (var i = 0; i < MAX_TEXTURES; i++) {\n            sampleValues[i] = i;\n          }\n          var uniforms = {\n            tint: new Float32Array([1, 1, 1, 1]),\n            translationMatrix: new core.Matrix(),\n            default: core.UniformGroup.from({\n              uSamplers: sampleValues\n            }, true)\n          };\n          var program = renderer.plugins[pluginName]._shader.program;\n          DEFAULT_SHADERS[pluginName] = new core.Shader(program, uniforms);\n        }\n        shader = DEFAULT_SHADERS[pluginName];\n      }\n      return shader;\n    }\n  }, {\n    key: \"_calculateBounds\",\n    value: function _calculateBounds() {\n      this.finishPoly();\n      var geometry = this._geometry;\n      if (!geometry.graphicsData.length) {\n        return;\n      }\n      var _geometry$bounds = geometry.bounds,\n        minX = _geometry$bounds.minX,\n        minY = _geometry$bounds.minY,\n        maxX = _geometry$bounds.maxX,\n        maxY = _geometry$bounds.maxY;\n      this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      this.worldTransform.applyInverse(point, _Graphics._TEMP_POINT);\n      return this._geometry.containsPoint(_Graphics._TEMP_POINT);\n    }\n  }, {\n    key: \"calculateTints\",\n    value: function calculateTints() {\n      if (this.batchTint !== this.tint) {\n        this.batchTint = this.tint;\n        var tintRGB = core.utils.hex2rgb(this.tint, temp);\n        for (var i = 0; i < this.batches.length; i++) {\n          var batch = this.batches[i];\n          var batchTint = batch._batchRGB;\n          var r = tintRGB[0] * batchTint[0] * 255;\n          var g = tintRGB[1] * batchTint[1] * 255;\n          var b = tintRGB[2] * batchTint[2] * 255;\n          var color = (r << 16) + (g << 8) + (b | 0);\n          batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);\n        }\n      }\n    }\n  }, {\n    key: \"calculateVertices\",\n    value: function calculateVertices() {\n      var wtID = this.transform._worldID;\n      if (this._transformID === wtID) {\n        return;\n      }\n      this._transformID = wtID;\n      var wt = this.transform.worldTransform;\n      var a = wt.a;\n      var b = wt.b;\n      var c = wt.c;\n      var d = wt.d;\n      var tx = wt.tx;\n      var ty = wt.ty;\n      var data = this._geometry.points;\n      var vertexData = this.vertexData;\n      var count = 0;\n      for (var i = 0; i < data.length; i += 2) {\n        var x = data[i];\n        var y = data[i + 1];\n        vertexData[count++] = a * x + c * y + tx;\n        vertexData[count++] = d * y + b * x + ty;\n      }\n    }\n  }, {\n    key: \"closePath\",\n    value: function closePath() {\n      var currentPath = this.currentPath;\n      if (currentPath) {\n        currentPath.closeStroke = true;\n        this.finishPoly();\n      }\n      return this;\n    }\n  }, {\n    key: \"setMatrix\",\n    value: function setMatrix(matrix) {\n      this._matrix = matrix;\n      return this;\n    }\n  }, {\n    key: \"beginHole\",\n    value: function beginHole() {\n      this.finishPoly();\n      this._holeMode = true;\n      return this;\n    }\n  }, {\n    key: \"endHole\",\n    value: function endHole() {\n      this.finishPoly();\n      this._holeMode = false;\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      this._geometry.refCount--;\n      if (this._geometry.refCount === 0) {\n        this._geometry.dispose();\n      }\n      this._matrix = null;\n      this.currentPath = null;\n      this._lineStyle.destroy();\n      this._lineStyle = null;\n      this._fillStyle.destroy();\n      this._fillStyle = null;\n      this._geometry = null;\n      this.shader = null;\n      this.vertexData = null;\n      this.batches.length = 0;\n      this.batches = null;\n      _get(_getPrototypeOf(_Graphics.prototype), \"destroy\", this).call(this, options);\n    }\n  }, {\n    key: \"geometry\",\n    get: function get() {\n      return this._geometry;\n    }\n  }, {\n    key: \"blendMode\",\n    set: function set(value) {\n      this.state.blendMode = value;\n    },\n    get: function get() {\n      return this.state.blendMode;\n    }\n  }, {\n    key: \"tint\",\n    get: function get() {\n      return this._tint;\n    },\n    set: function set(value) {\n      this._tint = value;\n    }\n  }, {\n    key: \"fill\",\n    get: function get() {\n      return this._fillStyle;\n    }\n  }, {\n    key: \"line\",\n    get: function get() {\n      return this._lineStyle;\n    }\n  }]);\n  return _Graphics;\n}(display.Container);\nvar Graphics = _Graphics;\nGraphics._TEMP_POINT = new core.Point();\nexports.Graphics = Graphics;","map":null,"metadata":{},"sourceType":"script"}