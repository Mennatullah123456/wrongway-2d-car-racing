{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { Point, Polygon, State, settings, DRAW_MODES } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { MeshBatchUvs } from './MeshBatchUvs.mjs';\nvar tempPoint = new Point();\nvar tempPolygon = new Polygon();\nvar _Mesh = /*#__PURE__*/function (_Container) {\n  _inherits(_Mesh, _Container);\n  function _Mesh(geometry, shader, state) {\n    var _this;\n    var drawMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DRAW_MODES.TRIANGLES;\n    _classCallCheck(this, _Mesh);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_Mesh).call(this));\n    _this.geometry = geometry;\n    _this.shader = shader;\n    _this.state = state || State.for2d();\n    _this.drawMode = drawMode;\n    _this.start = 0;\n    _this.size = 0;\n    _this.uvs = null;\n    _this.indices = null;\n    _this.vertexData = new Float32Array(1);\n    _this.vertexDirty = -1;\n    _this._transformID = -1;\n    _this._roundPixels = settings.ROUND_PIXELS;\n    _this.batchUvs = null;\n    return _this;\n  }\n  _createClass(_Mesh, [{\n    key: \"_render\",\n    value: function _render(renderer) {\n      var vertices = this.geometry.buffers[0].data;\n      var shader = this.shader;\n      if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {\n        this._renderToBatch(renderer);\n      } else {\n        this._renderDefault(renderer);\n      }\n    }\n  }, {\n    key: \"_renderDefault\",\n    value: function _renderDefault(renderer) {\n      var shader = this.shader;\n      shader.alpha = this.worldAlpha;\n      if (shader.update) {\n        shader.update();\n      }\n      renderer.batch.flush();\n      shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n      renderer.shader.bind(shader);\n      renderer.state.set(this.state);\n      renderer.geometry.bind(this.geometry, shader);\n      renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }\n  }, {\n    key: \"_renderToBatch\",\n    value: function _renderToBatch(renderer) {\n      var geometry = this.geometry;\n      var shader = this.shader;\n      if (shader.uvMatrix) {\n        shader.uvMatrix.update();\n        this.calculateUvs();\n      }\n      this.calculateVertices();\n      this.indices = geometry.indexBuffer.data;\n      this._tintRGB = shader._tintRGB;\n      this._texture = shader.texture;\n      var pluginName = this.material.pluginName;\n      renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n      renderer.plugins[pluginName].render(this);\n    }\n  }, {\n    key: \"calculateVertices\",\n    value: function calculateVertices() {\n      var geometry = this.geometry;\n      var verticesBuffer = geometry.buffers[0];\n      var vertices = verticesBuffer.data;\n      var vertexDirtyId = verticesBuffer._updateID;\n      if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {\n        return;\n      }\n      this._transformID = this.transform._worldID;\n      if (this.vertexData.length !== vertices.length) {\n        this.vertexData = new Float32Array(vertices.length);\n      }\n      var wt = this.transform.worldTransform;\n      var a = wt.a;\n      var b = wt.b;\n      var c = wt.c;\n      var d = wt.d;\n      var tx = wt.tx;\n      var ty = wt.ty;\n      var vertexData = this.vertexData;\n      for (var i = 0; i < vertexData.length / 2; i++) {\n        var x = vertices[i * 2];\n        var y = vertices[i * 2 + 1];\n        vertexData[i * 2] = a * x + c * y + tx;\n        vertexData[i * 2 + 1] = b * x + d * y + ty;\n      }\n      if (this._roundPixels) {\n        var resolution = settings.RESOLUTION;\n        for (var _i = 0; _i < vertexData.length; ++_i) {\n          vertexData[_i] = Math.round(vertexData[_i] * resolution) / resolution;\n        }\n      }\n      this.vertexDirty = vertexDirtyId;\n    }\n  }, {\n    key: \"calculateUvs\",\n    value: function calculateUvs() {\n      var geomUvs = this.geometry.buffers[1];\n      var shader = this.shader;\n      if (!shader.uvMatrix.isSimple) {\n        if (!this.batchUvs) {\n          this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n        }\n        this.batchUvs.update();\n        this.uvs = this.batchUvs.data;\n      } else {\n        this.uvs = geomUvs.data;\n      }\n    }\n  }, {\n    key: \"_calculateBounds\",\n    value: function _calculateBounds() {\n      this.calculateVertices();\n      this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      if (!this.getBounds().contains(point.x, point.y)) {\n        return false;\n      }\n      this.worldTransform.applyInverse(point, tempPoint);\n      var vertices = this.geometry.getBuffer(\"aVertexPosition\").data;\n      var points = tempPolygon.points;\n      var indices = this.geometry.getIndex().data;\n      var len = indices.length;\n      var step = this.drawMode === 4 ? 3 : 1;\n      for (var i = 0; i + 2 < len; i += step) {\n        var ind0 = indices[i] * 2;\n        var ind1 = indices[i + 1] * 2;\n        var ind2 = indices[i + 2] * 2;\n        points[0] = vertices[ind0];\n        points[1] = vertices[ind0 + 1];\n        points[2] = vertices[ind1];\n        points[3] = vertices[ind1 + 1];\n        points[4] = vertices[ind2];\n        points[5] = vertices[ind2 + 1];\n        if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      _get(_getPrototypeOf(_Mesh.prototype), \"destroy\", this).call(this, options);\n      if (this._cachedTexture) {\n        this._cachedTexture.destroy();\n        this._cachedTexture = null;\n      }\n      this.geometry = null;\n      this.shader = null;\n      this.state = null;\n      this.uvs = null;\n      this.indices = null;\n      this.vertexData = null;\n    }\n  }, {\n    key: \"geometry\",\n    get: function get() {\n      return this._geometry;\n    },\n    set: function set(value) {\n      if (this._geometry === value) {\n        return;\n      }\n      if (this._geometry) {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0) {\n          this._geometry.dispose();\n        }\n      }\n      this._geometry = value;\n      if (this._geometry) {\n        this._geometry.refCount++;\n      }\n      this.vertexDirty = -1;\n    }\n  }, {\n    key: \"uvBuffer\",\n    get: function get() {\n      return this.geometry.buffers[1];\n    }\n  }, {\n    key: \"verticesBuffer\",\n    get: function get() {\n      return this.geometry.buffers[0];\n    }\n  }, {\n    key: \"material\",\n    set: function set(value) {\n      this.shader = value;\n    },\n    get: function get() {\n      return this.shader;\n    }\n  }, {\n    key: \"blendMode\",\n    set: function set(value) {\n      this.state.blendMode = value;\n    },\n    get: function get() {\n      return this.state.blendMode;\n    }\n  }, {\n    key: \"roundPixels\",\n    set: function set(value) {\n      if (this._roundPixels !== value) {\n        this._transformID = -1;\n      }\n      this._roundPixels = value;\n    },\n    get: function get() {\n      return this._roundPixels;\n    }\n  }, {\n    key: \"tint\",\n    get: function get() {\n      return \"tint\" in this.shader ? this.shader.tint : null;\n    },\n    set: function set(value) {\n      this.shader.tint = value;\n    }\n  }, {\n    key: \"texture\",\n    get: function get() {\n      return \"texture\" in this.shader ? this.shader.texture : null;\n    },\n    set: function set(value) {\n      this.shader.texture = value;\n    }\n  }]);\n  return _Mesh;\n}(Container);\nvar Mesh = _Mesh;\nMesh.BATCHABLE_SIZE = 100;\nexport { Mesh };","map":null,"metadata":{},"sourceType":"module"}