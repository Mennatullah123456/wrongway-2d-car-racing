{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nrequire('./index.js');\nvar uniformParsers = require('./uniformParsers.js');\nvar mapSize = require('./mapSize.js');\nfunction uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {\n  _renderer.buffer.update(buffer);\n}\nvar UBO_TO_SINGLE_SETTERS = {\n  float: \"\\n        data[offset] = v;\\n    \",\n  vec2: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n    \",\n  vec3: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n        data[offset+2] = v[2];\\n\\n    \",\n  vec4: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n        data[offset+2] = v[2];\\n        data[offset+3] = v[3];\\n    \",\n  mat2: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n\\n        data[offset+4] = v[2];\\n        data[offset+5] = v[3];\\n    \",\n  mat3: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n        data[offset+2] = v[2];\\n\\n        data[offset + 4] = v[3];\\n        data[offset + 5] = v[4];\\n        data[offset + 6] = v[5];\\n\\n        data[offset + 8] = v[6];\\n        data[offset + 9] = v[7];\\n        data[offset + 10] = v[8];\\n    \",\n  mat4: \"\\n        for(var i = 0; i < 16; i++)\\n        {\\n            data[offset + i] = v[i];\\n        }\\n    \"\n};\nvar GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(uniformData) {\n  var uboElements = uniformData.map(function (data) {\n    return {\n      data: data,\n      offset: 0,\n      dataLen: 0,\n      dirty: 0\n    };\n  });\n  var size = 0;\n  var chunkSize = 0;\n  var offset = 0;\n  for (var i = 0; i < uboElements.length; i++) {\n    var uboElement = uboElements[i];\n    size = GLSL_TO_STD40_SIZE[uboElement.data.type];\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, 16) * uboElement.data.size;\n    }\n    uboElement.dataLen = size;\n    if (chunkSize % size !== 0 && chunkSize < 16) {\n      var lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue;\n      offset += lineUpValue;\n    }\n    if (chunkSize + size > 16) {\n      offset = Math.ceil(offset / 16) * 16;\n      uboElement.offset = offset;\n      offset += size;\n      chunkSize = size;\n    } else {\n      uboElement.offset = offset;\n      chunkSize += size;\n      offset += size;\n    }\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return {\n    uboElements: uboElements,\n    size: offset\n  };\n}\nfunction getUBOData(uniforms, uniformData) {\n  var usedUniformDatas = [];\n  for (var i in uniforms) {\n    if (uniformData[i]) {\n      usedUniformDatas.push(uniformData[i]);\n    }\n  }\n  usedUniformDatas.sort(function (a, b) {\n    return a.index - b.index;\n  });\n  return usedUniformDatas;\n}\nfunction generateUniformBufferSync(group, uniformData) {\n  if (!group.autoManage) {\n    return {\n      size: 0,\n      syncFunc: uboUpdate\n    };\n  }\n  var usedUniformDatas = getUBOData(group.uniforms, uniformData);\n  var _createUBOElements = createUBOElements(usedUniformDatas),\n    uboElements = _createUBOElements.uboElements,\n    size = _createUBOElements.size;\n  var funcFragments = [\"\\n    var v = null;\\n    var v2 = null;\\n    var cv = null;\\n    var t = 0;\\n    var gl = renderer.gl\\n    var index = 0;\\n    var data = buffer.data;\\n    \"];\n  for (var i = 0; i < uboElements.length; i++) {\n    var uboElement = uboElements[i];\n    var uniform = group.uniforms[uboElement.data.name];\n    var name = uboElement.data.name;\n    var parsed = false;\n    for (var j = 0; j < uniformParsers.uniformParsers.length; j++) {\n      var uniformParser = uniformParsers.uniformParsers[j];\n      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {\n        funcFragments.push(\"offset = \".concat(uboElement.offset / 4, \";\"), uniformParsers.uniformParsers[j].codeUbo(uboElement.data.name, uniform));\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        var size2 = mapSize.mapSize(uboElement.data.type);\n        var rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n        var elementSize = size2 / rowSize;\n        var remainder = (4 - elementSize % 4) % 4;\n        funcFragments.push(\"\\n                cv = ud.\".concat(name, \".value;\\n                v = uv.\").concat(name, \";\\n                offset = \").concat(uboElement.offset / 4, \";\\n\\n                t = 0;\\n\\n                for(var i=0; i < \").concat(uboElement.data.size * rowSize, \"; i++)\\n                {\\n                    for(var j = 0; j < \").concat(elementSize, \"; j++)\\n                    {\\n                        data[offset++] = v[t++];\\n                    }\\n                    offset += \").concat(remainder, \";\\n                }\\n\\n                \"));\n      } else {\n        var template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n        funcFragments.push(\"\\n                cv = ud.\".concat(name, \".value;\\n                v = uv.\").concat(name, \";\\n                offset = \").concat(uboElement.offset / 4, \";\\n                \").concat(template, \";\\n                \"));\n      }\n    }\n  }\n  funcFragments.push(\"\\n       renderer.buffer.update(buffer);\\n    \");\n  return {\n    size: size,\n    syncFunc: new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", \"buffer\", funcFragments.join(\"\\n\"))\n  };\n}\nexports.createUBOElements = createUBOElements;\nexports.generateUniformBufferSync = generateUniformBufferSync;\nexports.getUBOData = getUBOData;","map":null,"metadata":{},"sourceType":"script"}