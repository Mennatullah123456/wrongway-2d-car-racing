{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar mesh = require('@pixi/mesh');\nvar BitmapFont = require('./BitmapFont.js');\nrequire('./utils/index.js');\nvar msdf$1 = require('./shader/msdf.js');\nvar msdf = require('./shader/msdf2.js');\nvar core = require('@pixi/core');\nvar display = require('@pixi/display');\nvar splitTextToCharacters = require('./utils/splitTextToCharacters.js');\nvar extractCharCode = require('./utils/extractCharCode.js');\nvar pageMeshDataDefaultPageMeshData = [];\nvar pageMeshDataMSDFPageMeshData = [];\nvar charRenderDataPool = [];\nvar _BitmapText = /*#__PURE__*/function (_display$Container) {\n  _inherits(_BitmapText, _display$Container);\n  function _BitmapText(text) {\n    var _this;\n    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, _BitmapText);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_BitmapText).call(this));\n    _this._tint = 16777215;\n    var _Object$assign = Object.assign({}, _BitmapText.styleDefaults, style),\n      align = _Object$assign.align,\n      tint = _Object$assign.tint,\n      maxWidth = _Object$assign.maxWidth,\n      letterSpacing = _Object$assign.letterSpacing,\n      fontName = _Object$assign.fontName,\n      fontSize = _Object$assign.fontSize;\n    if (!BitmapFont.BitmapFont.available[fontName]) {\n      throw new Error(\"Missing BitmapFont \\\"\".concat(fontName, \"\\\"\"));\n    }\n    _this._activePagesMeshData = [];\n    _this._textWidth = 0;\n    _this._textHeight = 0;\n    _this._align = align;\n    _this._tint = tint;\n    _this._font = void 0;\n    _this._fontName = fontName;\n    _this._fontSize = fontSize;\n    _this.text = text;\n    _this._maxWidth = maxWidth;\n    _this._maxLineHeight = 0;\n    _this._letterSpacing = letterSpacing;\n    _this._anchor = new core.ObservablePoint(function () {\n      _this.dirty = true;\n    }, _assertThisInitialized(_assertThisInitialized(_this)), 0, 0);\n    _this._roundPixels = core.settings.ROUND_PIXELS;\n    _this.dirty = true;\n    _this._resolution = core.settings.RESOLUTION;\n    _this._autoResolution = true;\n    _this._textureCache = {};\n    return _this;\n  }\n  _createClass(_BitmapText, [{\n    key: \"updateText\",\n    value: function updateText() {\n      var data = BitmapFont.BitmapFont.available[this._fontName];\n      var fontSize = this.fontSize;\n      var scale = fontSize / data.size;\n      var pos = new core.Point();\n      var chars = [];\n      var lineWidths = [];\n      var lineSpaces = [];\n      var text = this._text.replace(/(?:\\r\\n|\\r)/g, \"\\n\") || \" \";\n      var charsInput = splitTextToCharacters.splitTextToCharacters(text);\n      var maxWidth = this._maxWidth * data.size / fontSize;\n      var pageMeshDataPool = data.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n      var prevCharCode = null;\n      var lastLineWidth = 0;\n      var maxLineWidth = 0;\n      var line = 0;\n      var lastBreakPos = -1;\n      var lastBreakWidth = 0;\n      var spacesRemoved = 0;\n      var maxLineHeight = 0;\n      var spaceCount = 0;\n      for (var i = 0; i < charsInput.length; i++) {\n        var char = charsInput[i];\n        var charCode = extractCharCode.extractCharCode(char);\n        if (/(?:\\s)/.test(char)) {\n          lastBreakPos = i;\n          lastBreakWidth = lastLineWidth;\n          spaceCount++;\n        }\n        if (char === \"\\r\" || char === \"\\n\") {\n          lineWidths.push(lastLineWidth);\n          lineSpaces.push(-1);\n          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n          ++line;\n          ++spacesRemoved;\n          pos.x = 0;\n          pos.y += data.lineHeight;\n          prevCharCode = null;\n          spaceCount = 0;\n          continue;\n        }\n        var charData = data.chars[charCode];\n        if (!charData) {\n          continue;\n        }\n        if (prevCharCode && charData.kerning[prevCharCode]) {\n          pos.x += charData.kerning[prevCharCode];\n        }\n        var charRenderData = charRenderDataPool.pop() || {\n          texture: core.Texture.EMPTY,\n          line: 0,\n          charCode: 0,\n          prevSpaces: 0,\n          position: new core.Point()\n        };\n        charRenderData.texture = charData.texture;\n        charRenderData.line = line;\n        charRenderData.charCode = charCode;\n        charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;\n        charRenderData.position.y = pos.y + charData.yOffset;\n        charRenderData.prevSpaces = spaceCount;\n        chars.push(charRenderData);\n        lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n        pos.x += charData.xAdvance + this._letterSpacing;\n        maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);\n        prevCharCode = charCode;\n        if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {\n          ++spacesRemoved;\n          core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n          i = lastBreakPos;\n          lastBreakPos = -1;\n          lineWidths.push(lastBreakWidth);\n          lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n          maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n          line++;\n          pos.x = 0;\n          pos.y += data.lineHeight;\n          prevCharCode = null;\n          spaceCount = 0;\n        }\n      }\n      var lastChar = charsInput[charsInput.length - 1];\n      if (lastChar !== \"\\r\" && lastChar !== \"\\n\") {\n        if (/(?:\\s)/.test(lastChar)) {\n          lastLineWidth = lastBreakWidth;\n        }\n        lineWidths.push(lastLineWidth);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        lineSpaces.push(-1);\n      }\n      var lineAlignOffsets = [];\n      for (var _i = 0; _i <= line; _i++) {\n        var alignOffset = 0;\n        if (this._align === \"right\") {\n          alignOffset = maxLineWidth - lineWidths[_i];\n        } else if (this._align === \"center\") {\n          alignOffset = (maxLineWidth - lineWidths[_i]) / 2;\n        } else if (this._align === \"justify\") {\n          alignOffset = lineSpaces[_i] < 0 ? 0 : (maxLineWidth - lineWidths[_i]) / lineSpaces[_i];\n        }\n        lineAlignOffsets.push(alignOffset);\n      }\n      var lenChars = chars.length;\n      var pagesMeshData = {};\n      var newPagesMeshData = [];\n      var activePagesMeshData = this._activePagesMeshData;\n      pageMeshDataPool.push.apply(pageMeshDataPool, _toConsumableArray(activePagesMeshData));\n      for (var _i2 = 0; _i2 < lenChars; _i2++) {\n        var texture = chars[_i2].texture;\n        var baseTextureUid = texture.baseTexture.uid;\n        if (!pagesMeshData[baseTextureUid]) {\n          var pageMeshData = pageMeshDataPool.pop();\n          if (!pageMeshData) {\n            var geometry = new mesh.MeshGeometry();\n            var material = void 0;\n            var meshBlendMode = void 0;\n            if (data.distanceFieldType === \"none\") {\n              material = new mesh.MeshMaterial(core.Texture.EMPTY);\n              meshBlendMode = core.BLEND_MODES.NORMAL;\n            } else {\n              material = new mesh.MeshMaterial(core.Texture.EMPTY, {\n                program: core.Program.from(msdf[\"default\"], msdf$1[\"default\"]),\n                uniforms: {\n                  uFWidth: 0\n                }\n              });\n              meshBlendMode = core.BLEND_MODES.NORMAL_NPM;\n            }\n            var mesh$1 = new mesh.Mesh(geometry, material);\n            mesh$1.blendMode = meshBlendMode;\n            pageMeshData = {\n              index: 0,\n              indexCount: 0,\n              vertexCount: 0,\n              uvsCount: 0,\n              total: 0,\n              mesh: mesh$1,\n              vertices: null,\n              uvs: null,\n              indices: null\n            };\n          }\n          pageMeshData.index = 0;\n          pageMeshData.indexCount = 0;\n          pageMeshData.vertexCount = 0;\n          pageMeshData.uvsCount = 0;\n          pageMeshData.total = 0;\n          var _textureCache = this._textureCache;\n          _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new core.Texture(texture.baseTexture);\n          pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n          pageMeshData.mesh.tint = this._tint;\n          newPagesMeshData.push(pageMeshData);\n          pagesMeshData[baseTextureUid] = pageMeshData;\n        }\n        pagesMeshData[baseTextureUid].total++;\n      }\n      for (var _i3 = 0; _i3 < activePagesMeshData.length; _i3++) {\n        if (!newPagesMeshData.includes(activePagesMeshData[_i3])) {\n          this.removeChild(activePagesMeshData[_i3].mesh);\n        }\n      }\n      for (var _i4 = 0; _i4 < newPagesMeshData.length; _i4++) {\n        if (newPagesMeshData[_i4].mesh.parent !== this) {\n          this.addChild(newPagesMeshData[_i4].mesh);\n        }\n      }\n      this._activePagesMeshData = newPagesMeshData;\n      for (var _i5 in pagesMeshData) {\n        var _pageMeshData = pagesMeshData[_i5];\n        var total = _pageMeshData.total;\n        if (!(_pageMeshData.indices?.length > 6 * total) || _pageMeshData.vertices.length < mesh.Mesh.BATCHABLE_SIZE * 2) {\n          _pageMeshData.vertices = new Float32Array(4 * 2 * total);\n          _pageMeshData.uvs = new Float32Array(4 * 2 * total);\n          _pageMeshData.indices = new Uint16Array(6 * total);\n        } else {\n          var total2 = _pageMeshData.total;\n          var vertices = _pageMeshData.vertices;\n          for (var i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {\n            vertices[i2] = 0;\n          }\n        }\n        _pageMeshData.mesh.size = 6 * total;\n      }\n      for (var _i6 = 0; _i6 < lenChars; _i6++) {\n        var _char = chars[_i6];\n        var offset = _char.position.x + lineAlignOffsets[_char.line] * (this._align === \"justify\" ? _char.prevSpaces : 1);\n        if (this._roundPixels) {\n          offset = Math.round(offset);\n        }\n        var xPos = offset * scale;\n        var yPos = _char.position.y * scale;\n        var _texture = _char.texture;\n        var pageMesh = pagesMeshData[_texture.baseTexture.uid];\n        var textureFrame = _texture.frame;\n        var textureUvs = _texture._uvs;\n        var index = pageMesh.index++;\n        pageMesh.indices[index * 6 + 0] = 0 + index * 4;\n        pageMesh.indices[index * 6 + 1] = 1 + index * 4;\n        pageMesh.indices[index * 6 + 2] = 2 + index * 4;\n        pageMesh.indices[index * 6 + 3] = 0 + index * 4;\n        pageMesh.indices[index * 6 + 4] = 2 + index * 4;\n        pageMesh.indices[index * 6 + 5] = 3 + index * 4;\n        pageMesh.vertices[index * 8 + 0] = xPos;\n        pageMesh.vertices[index * 8 + 1] = yPos;\n        pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;\n        pageMesh.vertices[index * 8 + 3] = yPos;\n        pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;\n        pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;\n        pageMesh.vertices[index * 8 + 6] = xPos;\n        pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;\n        pageMesh.uvs[index * 8 + 0] = textureUvs.x0;\n        pageMesh.uvs[index * 8 + 1] = textureUvs.y0;\n        pageMesh.uvs[index * 8 + 2] = textureUvs.x1;\n        pageMesh.uvs[index * 8 + 3] = textureUvs.y1;\n        pageMesh.uvs[index * 8 + 4] = textureUvs.x2;\n        pageMesh.uvs[index * 8 + 5] = textureUvs.y2;\n        pageMesh.uvs[index * 8 + 6] = textureUvs.x3;\n        pageMesh.uvs[index * 8 + 7] = textureUvs.y3;\n      }\n      this._textWidth = maxLineWidth * scale;\n      this._textHeight = (pos.y + data.lineHeight) * scale;\n      for (var _i7 in pagesMeshData) {\n        var _pageMeshData2 = pagesMeshData[_i7];\n        if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n          var vertexCount = 0;\n          var anchorOffsetX = this._textWidth * this.anchor.x;\n          var anchorOffsetY = this._textHeight * this.anchor.y;\n          for (var _i8 = 0; _i8 < _pageMeshData2.total; _i8++) {\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetX;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetY;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetX;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetY;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetX;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetY;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetX;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetY;\n          }\n        }\n        this._maxLineHeight = maxLineHeight * scale;\n        var vertexBuffer = _pageMeshData2.mesh.geometry.getBuffer(\"aVertexPosition\");\n        var textureBuffer = _pageMeshData2.mesh.geometry.getBuffer(\"aTextureCoord\");\n        var indexBuffer = _pageMeshData2.mesh.geometry.getIndex();\n        vertexBuffer.data = _pageMeshData2.vertices;\n        textureBuffer.data = _pageMeshData2.uvs;\n        indexBuffer.data = _pageMeshData2.indices;\n        vertexBuffer.update();\n        textureBuffer.update();\n        indexBuffer.update();\n      }\n      for (var _i9 = 0; _i9 < chars.length; _i9++) {\n        charRenderDataPool.push(chars[_i9]);\n      }\n      this._font = data;\n      this.dirty = false;\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform() {\n      this.validate();\n      this.containerUpdateTransform();\n    }\n  }, {\n    key: \"_render\",\n    value: function _render(renderer) {\n      if (this._autoResolution && this._resolution !== renderer.resolution) {\n        this._resolution = renderer.resolution;\n        this.dirty = true;\n      }\n      var _BitmapFont$BitmapFon = BitmapFont.BitmapFont.available[this._fontName],\n        distanceFieldRange = _BitmapFont$BitmapFon.distanceFieldRange,\n        distanceFieldType = _BitmapFont$BitmapFon.distanceFieldType,\n        size = _BitmapFont$BitmapFon.size;\n      if (distanceFieldType !== \"none\") {\n        var _this$worldTransform = this.worldTransform,\n          a = _this$worldTransform.a,\n          b = _this$worldTransform.b,\n          c = _this$worldTransform.c,\n          d = _this$worldTransform.d;\n        var dx = Math.sqrt(a * a + b * b);\n        var dy = Math.sqrt(c * c + d * d);\n        var worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n        var fontScale = this.fontSize / size;\n        var resolution = renderer._view.resolution;\n        var _iterator = _createForOfIteratorHelper(this._activePagesMeshData),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _mesh = _step.value;\n            _mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      _get(_getPrototypeOf(_BitmapText.prototype), \"_render\", this).call(this, renderer);\n    }\n  }, {\n    key: \"getLocalBounds\",\n    value: function getLocalBounds() {\n      this.validate();\n      return _get(_getPrototypeOf(_BitmapText.prototype), \"getLocalBounds\", this).call(this);\n    }\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      var font = BitmapFont.BitmapFont.available[this._fontName];\n      if (!font) {\n        throw new Error(\"Missing BitmapFont \\\"\".concat(this._fontName, \"\\\"\"));\n      }\n      if (this._font !== font) {\n        this.dirty = true;\n      }\n      if (this.dirty) {\n        this.updateText();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      var _textureCache = this._textureCache;\n      var data = BitmapFont.BitmapFont.available[this._fontName];\n      var pageMeshDataPool = data.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n      pageMeshDataPool.push.apply(pageMeshDataPool, _toConsumableArray(this._activePagesMeshData));\n      var _iterator2 = _createForOfIteratorHelper(this._activePagesMeshData),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var pageMeshData = _step2.value;\n          this.removeChild(pageMeshData.mesh);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this._activePagesMeshData = [];\n      pageMeshDataPool.filter(function (page) {\n        return _textureCache[page.mesh.texture.baseTexture.uid];\n      }).forEach(function (page) {\n        page.mesh.texture = core.Texture.EMPTY;\n      });\n      for (var id in _textureCache) {\n        var texture = _textureCache[id];\n        texture.destroy();\n        delete _textureCache[id];\n      }\n      this._font = null;\n      this._textureCache = null;\n      _get(_getPrototypeOf(_BitmapText.prototype), \"destroy\", this).call(this, options);\n    }\n  }, {\n    key: \"tint\",\n    get: function get() {\n      return this._tint;\n    },\n    set: function set(value) {\n      if (this._tint === value) return;\n      this._tint = value;\n      for (var i = 0; i < this._activePagesMeshData.length; i++) {\n        this._activePagesMeshData[i].mesh.tint = value;\n      }\n    }\n  }, {\n    key: \"align\",\n    get: function get() {\n      return this._align;\n    },\n    set: function set(value) {\n      if (this._align !== value) {\n        this._align = value;\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"fontName\",\n    get: function get() {\n      return this._fontName;\n    },\n    set: function set(value) {\n      if (!BitmapFont.BitmapFont.available[value]) {\n        throw new Error(\"Missing BitmapFont \\\"\".concat(value, \"\\\"\"));\n      }\n      if (this._fontName !== value) {\n        this._fontName = value;\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"fontSize\",\n    get: function get() {\n      return this._fontSize ?? BitmapFont.BitmapFont.available[this._fontName].size;\n    },\n    set: function set(value) {\n      if (this._fontSize !== value) {\n        this._fontSize = value;\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      return this._anchor;\n    },\n    set: function set(value) {\n      if (typeof value === \"number\") {\n        this._anchor.set(value);\n      } else {\n        this._anchor.copyFrom(value);\n      }\n    }\n  }, {\n    key: \"text\",\n    get: function get() {\n      return this._text;\n    },\n    set: function set(text) {\n      text = String(text === null || text === void 0 ? \"\" : text);\n      if (this._text === text) {\n        return;\n      }\n      this._text = text;\n      this.dirty = true;\n    }\n  }, {\n    key: \"maxWidth\",\n    get: function get() {\n      return this._maxWidth;\n    },\n    set: function set(value) {\n      if (this._maxWidth === value) {\n        return;\n      }\n      this._maxWidth = value;\n      this.dirty = true;\n    }\n  }, {\n    key: \"maxLineHeight\",\n    get: function get() {\n      this.validate();\n      return this._maxLineHeight;\n    }\n  }, {\n    key: \"textWidth\",\n    get: function get() {\n      this.validate();\n      return this._textWidth;\n    }\n  }, {\n    key: \"letterSpacing\",\n    get: function get() {\n      return this._letterSpacing;\n    },\n    set: function set(value) {\n      if (this._letterSpacing !== value) {\n        this._letterSpacing = value;\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"roundPixels\",\n    get: function get() {\n      return this._roundPixels;\n    },\n    set: function set(value) {\n      if (value !== this._roundPixels) {\n        this._roundPixels = value;\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"textHeight\",\n    get: function get() {\n      this.validate();\n      return this._textHeight;\n    }\n  }, {\n    key: \"resolution\",\n    get: function get() {\n      return this._resolution;\n    },\n    set: function set(value) {\n      this._autoResolution = false;\n      if (this._resolution === value) {\n        return;\n      }\n      this._resolution = value;\n      this.dirty = true;\n    }\n  }]);\n  return _BitmapText;\n}(display.Container);\nvar BitmapText = _BitmapText;\nBitmapText.styleDefaults = {\n  align: \"left\",\n  tint: 16777215,\n  maxWidth: 0,\n  letterSpacing: 0\n};\nexports.BitmapText = BitmapText;","map":null,"metadata":{},"sourceType":"script"}