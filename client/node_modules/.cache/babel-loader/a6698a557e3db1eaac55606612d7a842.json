{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar DisplayObject = require('./DisplayObject.js');\nvar tempMatrix = new core.Matrix();\nfunction _sortChildren(a, b) {\n  if (a.zIndex === b.zIndex) {\n    return a._lastSortedIndex - b._lastSortedIndex;\n  }\n  return a.zIndex - b.zIndex;\n}\nvar Container = /*#__PURE__*/function (_DisplayObject$Displa) {\n  _inherits(Container, _DisplayObject$Displa);\n  function Container() {\n    var _this;\n    _classCallCheck(this, Container);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Container).call(this));\n    _this.children = [];\n    _this.sortableChildren = core.settings.SORTABLE_CHILDREN;\n    _this.sortDirty = false;\n    return _this;\n  }\n  _createClass(Container, [{\n    key: \"onChildrenChange\",\n    value: function onChildrenChange(_length) {}\n  }, {\n    key: \"addChild\",\n    value: function addChild() {\n      if (arguments.length > 1) {\n        for (var i = 0; i < arguments.length; i++) {\n          this.addChild(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n        }\n      } else {\n        var child = arguments.length <= 0 ? undefined : arguments[0];\n        if (child.parent) {\n          child.parent.removeChild(child);\n        }\n        child.parent = this;\n        this.sortDirty = true;\n        child.transform._parentID = -1;\n        this.children.push(child);\n        this._boundsID++;\n        this.onChildrenChange(this.children.length - 1);\n        this.emit(\"childAdded\", child, this, this.children.length - 1);\n        child.emit(\"added\", this);\n      }\n      return arguments.length <= 0 ? undefined : arguments[0];\n    }\n  }, {\n    key: \"addChildAt\",\n    value: function addChildAt(child, index) {\n      if (index < 0 || index > this.children.length) {\n        throw new Error(\"\".concat(child, \"addChildAt: The index \").concat(index, \" supplied is out of bounds \").concat(this.children.length));\n      }\n      if (child.parent) {\n        child.parent.removeChild(child);\n      }\n      child.parent = this;\n      this.sortDirty = true;\n      child.transform._parentID = -1;\n      this.children.splice(index, 0, child);\n      this._boundsID++;\n      this.onChildrenChange(index);\n      child.emit(\"added\", this);\n      this.emit(\"childAdded\", child, this, index);\n      return child;\n    }\n  }, {\n    key: \"swapChildren\",\n    value: function swapChildren(child, child2) {\n      if (child === child2) {\n        return;\n      }\n      var index1 = this.getChildIndex(child);\n      var index2 = this.getChildIndex(child2);\n      this.children[index1] = child2;\n      this.children[index2] = child;\n      this.onChildrenChange(index1 < index2 ? index1 : index2);\n    }\n  }, {\n    key: \"getChildIndex\",\n    value: function getChildIndex(child) {\n      var index = this.children.indexOf(child);\n      if (index === -1) {\n        throw new Error(\"The supplied DisplayObject must be a child of the caller\");\n      }\n      return index;\n    }\n  }, {\n    key: \"setChildIndex\",\n    value: function setChildIndex(child, index) {\n      if (index < 0 || index >= this.children.length) {\n        throw new Error(\"The index \".concat(index, \" supplied is out of bounds \").concat(this.children.length));\n      }\n      var currentIndex = this.getChildIndex(child);\n      core.utils.removeItems(this.children, currentIndex, 1);\n      this.children.splice(index, 0, child);\n      this.onChildrenChange(index);\n    }\n  }, {\n    key: \"getChildAt\",\n    value: function getChildAt(index) {\n      if (index < 0 || index >= this.children.length) {\n        throw new Error(\"getChildAt: Index (\".concat(index, \") does not exist.\"));\n      }\n      return this.children[index];\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild() {\n      if (arguments.length > 1) {\n        for (var i = 0; i < arguments.length; i++) {\n          this.removeChild(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n        }\n      } else {\n        var child = arguments.length <= 0 ? undefined : arguments[0];\n        var index = this.children.indexOf(child);\n        if (index === -1) return null;\n        child.parent = null;\n        child.transform._parentID = -1;\n        core.utils.removeItems(this.children, index, 1);\n        this._boundsID++;\n        this.onChildrenChange(index);\n        child.emit(\"removed\", this);\n        this.emit(\"childRemoved\", child, this, index);\n      }\n      return arguments.length <= 0 ? undefined : arguments[0];\n    }\n  }, {\n    key: \"removeChildAt\",\n    value: function removeChildAt(index) {\n      var child = this.getChildAt(index);\n      child.parent = null;\n      child.transform._parentID = -1;\n      core.utils.removeItems(this.children, index, 1);\n      this._boundsID++;\n      this.onChildrenChange(index);\n      child.emit(\"removed\", this);\n      this.emit(\"childRemoved\", child, this, index);\n      return child;\n    }\n  }, {\n    key: \"removeChildren\",\n    value: function removeChildren() {\n      var beginIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var endIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.children.length;\n      var begin = beginIndex;\n      var end = endIndex;\n      var range = end - begin;\n      var removed;\n      if (range > 0 && range <= end) {\n        removed = this.children.splice(begin, range);\n        for (var i = 0; i < removed.length; ++i) {\n          removed[i].parent = null;\n          if (removed[i].transform) {\n            removed[i].transform._parentID = -1;\n          }\n        }\n        this._boundsID++;\n        this.onChildrenChange(beginIndex);\n        for (var _i = 0; _i < removed.length; ++_i) {\n          removed[_i].emit(\"removed\", this);\n          this.emit(\"childRemoved\", removed[_i], this, _i);\n        }\n        return removed;\n      } else if (range === 0 && this.children.length === 0) {\n        return [];\n      }\n      throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n    }\n  }, {\n    key: \"sortChildren\",\n    value: function sortChildren() {\n      var sortRequired = false;\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        var child = this.children[i];\n        child._lastSortedIndex = i;\n        if (!sortRequired && child.zIndex !== 0) {\n          sortRequired = true;\n        }\n      }\n      if (sortRequired && this.children.length > 1) {\n        this.children.sort(_sortChildren);\n      }\n      this.sortDirty = false;\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform() {\n      if (this.sortableChildren && this.sortDirty) {\n        this.sortChildren();\n      }\n      this._boundsID++;\n      this.transform.updateTransform(this.parent.transform);\n      this.worldAlpha = this.alpha * this.parent.worldAlpha;\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        var child = this.children[i];\n        if (child.visible) {\n          child.updateTransform();\n        }\n      }\n    }\n  }, {\n    key: \"calculateBounds\",\n    value: function calculateBounds() {\n      this._bounds.clear();\n      this._calculateBounds();\n      for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!child.visible || !child.renderable) {\n          continue;\n        }\n        child.calculateBounds();\n        if (child._mask) {\n          var maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;\n          if (maskObject) {\n            maskObject.calculateBounds();\n            this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n          } else {\n            this._bounds.addBounds(child._bounds);\n          }\n        } else if (child.filterArea) {\n          this._bounds.addBoundsArea(child._bounds, child.filterArea);\n        } else {\n          this._bounds.addBounds(child._bounds);\n        }\n      }\n      this._bounds.updateID = this._boundsID;\n    }\n  }, {\n    key: \"getLocalBounds\",\n    value: function getLocalBounds(rect) {\n      var skipChildrenUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var result = _get(_getPrototypeOf(Container.prototype), \"getLocalBounds\", this).call(this, rect);\n      if (!skipChildrenUpdate) {\n        for (var i = 0, j = this.children.length; i < j; ++i) {\n          var child = this.children[i];\n          if (child.visible) {\n            child.updateTransform();\n          }\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"_calculateBounds\",\n    value: function _calculateBounds() {}\n  }, {\n    key: \"_renderWithCulling\",\n    value: function _renderWithCulling(renderer) {\n      var sourceFrame = renderer.renderTexture.sourceFrame;\n      if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {\n        return;\n      }\n      var bounds;\n      var transform;\n      if (this.cullArea) {\n        bounds = this.cullArea;\n        transform = this.worldTransform;\n      } else if (this._render !== Container.prototype._render) {\n        bounds = this.getBounds(true);\n      }\n      var projectionTransform = renderer.projection.transform;\n      if (projectionTransform) {\n        if (transform) {\n          transform = tempMatrix.copyFrom(transform);\n          transform.prepend(projectionTransform);\n        } else {\n          transform = projectionTransform;\n        }\n      }\n      if (bounds && sourceFrame.intersects(bounds, transform)) {\n        this._render(renderer);\n      } else if (this.cullArea) {\n        return;\n      }\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        var child = this.children[i];\n        var childCullable = child.cullable;\n        child.cullable = childCullable || !this.cullArea;\n        child.render(renderer);\n        child.cullable = childCullable;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer) {\n      if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n        return;\n      }\n      if (this._mask || this.filters?.length) {\n        this.renderAdvanced(renderer);\n      } else if (this.cullable) {\n        this._renderWithCulling(renderer);\n      } else {\n        this._render(renderer);\n        for (var i = 0, j = this.children.length; i < j; ++i) {\n          this.children[i].render(renderer);\n        }\n      }\n    }\n  }, {\n    key: \"renderAdvanced\",\n    value: function renderAdvanced(renderer) {\n      var filters = this.filters;\n      var mask = this._mask;\n      if (filters) {\n        if (!this._enabledFilters) {\n          this._enabledFilters = [];\n        }\n        this._enabledFilters.length = 0;\n        for (var i = 0; i < filters.length; i++) {\n          if (filters[i].enabled) {\n            this._enabledFilters.push(filters[i]);\n          }\n        }\n      }\n      var flush = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== core.MASK_TYPES.NONE));\n      if (flush) {\n        renderer.batch.flush();\n      }\n      if (filters && this._enabledFilters?.length) {\n        renderer.filter.push(this, this._enabledFilters);\n      }\n      if (mask) {\n        renderer.mask.push(this, this._mask);\n      }\n      if (this.cullable) {\n        this._renderWithCulling(renderer);\n      } else {\n        this._render(renderer);\n        for (var _i2 = 0, j = this.children.length; _i2 < j; ++_i2) {\n          this.children[_i2].render(renderer);\n        }\n      }\n      if (flush) {\n        renderer.batch.flush();\n      }\n      if (mask) {\n        renderer.mask.pop(this);\n      }\n      if (filters && this._enabledFilters?.length) {\n        renderer.filter.pop();\n      }\n    }\n  }, {\n    key: \"_render\",\n    value: function _render(_renderer) {}\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      _get(_getPrototypeOf(Container.prototype), \"destroy\", this).call(this);\n      this.sortDirty = false;\n      var destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n      var oldChildren = this.removeChildren(0, this.children.length);\n      if (destroyChildren) {\n        for (var i = 0; i < oldChildren.length; ++i) {\n          oldChildren[i].destroy(options);\n        }\n      }\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function set(value) {\n      var width = this.getLocalBounds().width;\n      if (width !== 0) {\n        this.scale.x = value / width;\n      } else {\n        this.scale.x = 1;\n      }\n      this._width = value;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.scale.y * this.getLocalBounds().height;\n    },\n    set: function set(value) {\n      var height = this.getLocalBounds().height;\n      if (height !== 0) {\n        this.scale.y = value / height;\n      } else {\n        this.scale.y = 1;\n      }\n      this._height = value;\n    }\n  }]);\n  return Container;\n}(DisplayObject.DisplayObject);\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\nexports.Container = Container;","map":null,"metadata":{},"sourceType":"script"}