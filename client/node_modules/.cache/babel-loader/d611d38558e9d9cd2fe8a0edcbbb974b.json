{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar Attribute = require('./Attribute.js');\nvar Buffer = require('./Buffer.js');\nvar interleaveTypedArrays = require('./utils/interleaveTypedArrays.js');\nvar utils = require('@pixi/utils');\nvar runner = require('@pixi/runner');\nvar constants = require('@pixi/constants');\nvar byteSizeMap = {\n  5126: 4,\n  5123: 2,\n  5121: 1\n};\nvar UID = 0;\nvar map = {\n  Float32Array: Float32Array,\n  Uint32Array: Uint32Array,\n  Int32Array: Int32Array,\n  Uint8Array: Uint8Array,\n  Uint16Array: Uint16Array\n};\nvar Geometry = /*#__PURE__*/function () {\n  function Geometry() {\n    var buffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Geometry);\n    this.buffers = buffers;\n    this.indexBuffer = null;\n    this.attributes = attributes;\n    this.glVertexArrayObjects = {};\n    this.id = UID++;\n    this.instanced = false;\n    this.instanceCount = 1;\n    this.disposeRunner = new runner.Runner(\"disposeGeometry\");\n    this.refCount = 0;\n  }\n  _createClass(Geometry, [{\n    key: \"addAttribute\",\n    value: function addAttribute(id, buffer) {\n      var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var normalized = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var type = arguments.length > 4 ? arguments[4] : undefined;\n      var stride = arguments.length > 5 ? arguments[5] : undefined;\n      var start = arguments.length > 6 ? arguments[6] : undefined;\n      var instance = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n      if (!buffer) {\n        throw new Error(\"You must pass a buffer when creating an attribute\");\n      }\n      if (!(buffer instanceof Buffer.Buffer)) {\n        if (buffer instanceof Array) {\n          buffer = new Float32Array(buffer);\n        }\n        buffer = new Buffer.Buffer(buffer);\n      }\n      var ids = id.split(\"|\");\n      if (ids.length > 1) {\n        for (var i = 0; i < ids.length; i++) {\n          this.addAttribute(ids[i], buffer, size, normalized, type);\n        }\n        return this;\n      }\n      var bufferIndex = this.buffers.indexOf(buffer);\n      if (bufferIndex === -1) {\n        this.buffers.push(buffer);\n        bufferIndex = this.buffers.length - 1;\n      }\n      this.attributes[id] = new Attribute.Attribute(bufferIndex, size, normalized, type, stride, start, instance);\n      this.instanced = this.instanced || instance;\n      return this;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(id) {\n      return this.attributes[id];\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(id) {\n      return this.buffers[this.getAttribute(id).buffer];\n    }\n  }, {\n    key: \"addIndex\",\n    value: function addIndex(buffer) {\n      if (!(buffer instanceof Buffer.Buffer)) {\n        if (buffer instanceof Array) {\n          buffer = new Uint16Array(buffer);\n        }\n        buffer = new Buffer.Buffer(buffer);\n      }\n      buffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n      this.indexBuffer = buffer;\n      if (!this.buffers.includes(buffer)) {\n        this.buffers.push(buffer);\n      }\n      return this;\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex() {\n      return this.indexBuffer;\n    }\n  }, {\n    key: \"interleave\",\n    value: function interleave() {\n      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) return this;\n      var arrays = [];\n      var sizes = [];\n      var interleavedBuffer = new Buffer.Buffer();\n      var i;\n      for (i in this.attributes) {\n        var attribute = this.attributes[i];\n        var buffer = this.buffers[attribute.buffer];\n        arrays.push(buffer.data);\n        sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);\n        attribute.buffer = 0;\n      }\n      interleavedBuffer.data = interleaveTypedArrays.interleaveTypedArrays(arrays, sizes);\n      for (i = 0; i < this.buffers.length; i++) {\n        if (this.buffers[i] !== this.indexBuffer) {\n          this.buffers[i].destroy();\n        }\n      }\n      this.buffers = [interleavedBuffer];\n      if (this.indexBuffer) {\n        this.buffers.push(this.indexBuffer);\n      }\n      return this;\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      for (var i in this.attributes) {\n        var attribute = this.attributes[i];\n        var buffer = this.buffers[attribute.buffer];\n        return buffer.data.length / (attribute.stride / 4 || attribute.size);\n      }\n      return 0;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.disposeRunner.emit(this, false);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.dispose();\n      this.buffers = null;\n      this.indexBuffer = null;\n      this.attributes = null;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var geometry = new Geometry();\n      for (var i = 0; i < this.buffers.length; i++) {\n        geometry.buffers[i] = new Buffer.Buffer(this.buffers[i].data.slice(0));\n      }\n      for (var _i in this.attributes) {\n        var attrib = this.attributes[_i];\n        geometry.attributes[_i] = new Attribute.Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);\n      }\n      if (this.indexBuffer) {\n        geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];\n        geometry.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n      }\n      return geometry;\n    }\n  }], [{\n    key: \"merge\",\n    value: function merge(geometries) {\n      var geometryOut = new Geometry();\n      var arrays = [];\n      var sizes = [];\n      var offsets = [];\n      var geometry;\n      for (var i = 0; i < geometries.length; i++) {\n        geometry = geometries[i];\n        for (var j = 0; j < geometry.buffers.length; j++) {\n          sizes[j] = sizes[j] || 0;\n          sizes[j] += geometry.buffers[j].data.length;\n          offsets[j] = 0;\n        }\n      }\n      for (var _i2 = 0; _i2 < geometry.buffers.length; _i2++) {\n        arrays[_i2] = new map[utils.getBufferType(geometry.buffers[_i2].data)](sizes[_i2]);\n        geometryOut.buffers[_i2] = new Buffer.Buffer(arrays[_i2]);\n      }\n      for (var _i3 = 0; _i3 < geometries.length; _i3++) {\n        geometry = geometries[_i3];\n        for (var _j = 0; _j < geometry.buffers.length; _j++) {\n          arrays[_j].set(geometry.buffers[_j].data, offsets[_j]);\n          offsets[_j] += geometry.buffers[_j].data.length;\n        }\n      }\n      geometryOut.attributes = geometry.attributes;\n      if (geometry.indexBuffer) {\n        geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];\n        geometryOut.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        var offset = 0;\n        var stride = 0;\n        var offset2 = 0;\n        var bufferIndexToCount = 0;\n        for (var _i4 = 0; _i4 < geometry.buffers.length; _i4++) {\n          if (geometry.buffers[_i4] !== geometry.indexBuffer) {\n            bufferIndexToCount = _i4;\n            break;\n          }\n        }\n        for (var _i5 in geometry.attributes) {\n          var attribute = geometry.attributes[_i5];\n          if ((attribute.buffer | 0) === bufferIndexToCount) {\n            stride += attribute.size * byteSizeMap[attribute.type] / 4;\n          }\n        }\n        for (var _i6 = 0; _i6 < geometries.length; _i6++) {\n          var indexBufferData = geometries[_i6].indexBuffer.data;\n          for (var _j2 = 0; _j2 < indexBufferData.length; _j2++) {\n            geometryOut.indexBuffer.data[_j2 + offset2] += offset;\n          }\n          offset += geometries[_i6].buffers[bufferIndexToCount].data.length / stride;\n          offset2 += indexBufferData.length;\n        }\n      }\n      return geometryOut;\n    }\n  }]);\n  return Geometry;\n}();\nexports.Geometry = Geometry;","map":null,"metadata":{},"sourceType":"script"}