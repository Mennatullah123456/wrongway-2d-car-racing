{"ast":null,"code":"import { SHAPES } from '@pixi/core';\nvar buildCircle = {\n  build: function build(graphicsData) {\n    var points = graphicsData.points;\n    var x;\n    var y;\n    var dx;\n    var dy;\n    var rx;\n    var ry;\n    if (graphicsData.type === SHAPES.CIRC) {\n      var circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === SHAPES.ELIP) {\n      var ellipse = graphicsData.shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      var roundedRect = graphicsData.shape;\n      var halfWidth = roundedRect.width / 2;\n      var halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      points.length = 0;\n      return;\n    }\n    var n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    var m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m;\n    if (m === 0) {\n      return;\n    }\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return;\n    }\n    var j1 = 0;\n    var j2 = n * 4 + (dx ? 2 : 0) + 2;\n    var j3 = j2;\n    var j4 = m;\n    {\n      var x0 = dx + rx;\n      var y0 = dy;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      if (dy) {\n        var y2 = y - y0;\n        points[j3++] = x2;\n        points[j3++] = y2;\n        points[--j4] = y2;\n        points[--j4] = x1;\n      }\n    }\n    for (var i = 1; i < n; i++) {\n      var a = Math.PI / 2 * (i / n);\n      var _x = dx + Math.cos(a) * rx;\n      var _y = dy + Math.sin(a) * ry;\n      var _x2 = x + _x;\n      var _x3 = x - _x;\n      var _y2 = y + _y;\n      var _y3 = y - _y;\n      points[j1++] = _x2;\n      points[j1++] = _y2;\n      points[--j2] = _y2;\n      points[--j2] = _x3;\n      points[j3++] = _x3;\n      points[j3++] = _y3;\n      points[--j4] = _y3;\n      points[--j4] = _x2;\n    }\n    {\n      var _x4 = dx;\n      var _y4 = dy + ry;\n      var _x5 = x + _x4;\n      var _x6 = x - _x4;\n      var _y5 = y + _y4;\n      var _y6 = y - _y4;\n      points[j1++] = _x5;\n      points[j1++] = _y5;\n      points[--j4] = _y6;\n      points[--j4] = _x5;\n      if (dx) {\n        points[j1++] = _x6;\n        points[j1++] = _y5;\n        points[--j4] = _y6;\n        points[--j4] = _x6;\n      }\n    }\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    if (points.length === 0) {\n      return;\n    }\n    var vertPos = verts.length / 2;\n    var center = vertPos;\n    var x;\n    var y;\n    if (graphicsData.type !== SHAPES.RREC) {\n      var circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n    } else {\n      var roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2;\n      y = roundedRect.y + roundedRect.height / 2;\n    }\n    var matrix = graphicsData.matrix;\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    vertPos++;\n    verts.push(points[0], points[1]);\n    for (var i = 2; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]);\n      indices.push(vertPos++, center, vertPos);\n    }\n    indices.push(center + 1, center, vertPos);\n  }\n};\nexport { buildCircle };","map":null,"metadata":{},"sourceType":"module"}