{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _objectWithoutProperties = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/objectWithoutProperties\");\nvar _slicedToArray = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar text = require('@pixi/text');\nvar index = require('./formats/index.js');\nvar BitmapFontData = require('./BitmapFontData.js');\nrequire('./utils/index.js');\nvar resolveCharacters = require('./utils/resolveCharacters.js');\nvar drawGlyph = require('./utils/drawGlyph.js');\nvar extractCharCode = require('./utils/extractCharCode.js');\nvar _BitmapFont = /*#__PURE__*/function () {\n  function _BitmapFont(data, textures, ownsTextures) {\n    _classCallCheck(this, _BitmapFont);\n    var _data$info = _slicedToArray(data.info, 1),\n      info = _data$info[0];\n    var _data$common = _slicedToArray(data.common, 1),\n      common = _data$common[0];\n    var _data$page = _slicedToArray(data.page, 1),\n      page = _data$page[0];\n    var _data$distanceField = _slicedToArray(data.distanceField, 1),\n      distanceField = _data$distanceField[0];\n    var res = core.utils.getResolutionOfUrl(page.file);\n    var pageTextures = {};\n    this._ownsTextures = ownsTextures;\n    this.font = info.face;\n    this.size = info.size;\n    this.lineHeight = common.lineHeight / res;\n    this.chars = {};\n    this.pageTextures = pageTextures;\n    for (var i = 0; i < data.page.length; i++) {\n      var _data$page$i = data.page[i],\n        id = _data$page$i.id,\n        file = _data$page$i.file;\n      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];\n      if (distanceField?.fieldType && distanceField.fieldType !== \"none\") {\n        pageTextures[id].baseTexture.alphaMode = core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;\n        pageTextures[id].baseTexture.mipmap = core.MIPMAP_MODES.OFF;\n      }\n    }\n    for (var _i = 0; _i < data.char.length; _i++) {\n      var _data$char$_i = data.char[_i],\n        _id = _data$char$_i.id,\n        page2 = _data$char$_i.page;\n      var _data$char$_i2 = data.char[_i],\n        x = _data$char$_i2.x,\n        y = _data$char$_i2.y,\n        width = _data$char$_i2.width,\n        height = _data$char$_i2.height,\n        xoffset = _data$char$_i2.xoffset,\n        yoffset = _data$char$_i2.yoffset,\n        xadvance = _data$char$_i2.xadvance;\n      x /= res;\n      y /= res;\n      width /= res;\n      height /= res;\n      xoffset /= res;\n      yoffset /= res;\n      xadvance /= res;\n      var rect = new core.Rectangle(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);\n      this.chars[_id] = {\n        xOffset: xoffset,\n        yOffset: yoffset,\n        xAdvance: xadvance,\n        kerning: {},\n        texture: new core.Texture(pageTextures[page2].baseTexture, rect),\n        page: page2\n      };\n    }\n    for (var _i2 = 0; _i2 < data.kerning.length; _i2++) {\n      var _data$kerning$_i = data.kerning[_i2],\n        first = _data$kerning$_i.first,\n        second = _data$kerning$_i.second,\n        amount = _data$kerning$_i.amount;\n      first /= res;\n      second /= res;\n      amount /= res;\n      if (this.chars[second]) {\n        this.chars[second].kerning[first] = amount;\n      }\n    }\n    this.distanceFieldRange = distanceField?.distanceRange;\n    this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? \"none\";\n  }\n  _createClass(_BitmapFont, [{\n    key: \"destroy\",\n    value: function destroy() {\n      for (var id in this.chars) {\n        this.chars[id].texture.destroy();\n        this.chars[id].texture = null;\n      }\n      for (var _id2 in this.pageTextures) {\n        if (this._ownsTextures) {\n          this.pageTextures[_id2].destroy(true);\n        }\n        this.pageTextures[_id2] = null;\n      }\n      this.chars = null;\n      this.pageTextures = null;\n    }\n  }], [{\n    key: \"install\",\n    value: function install(data, textures, ownsTextures) {\n      var fontData;\n      if (data instanceof BitmapFontData.BitmapFontData) {\n        fontData = data;\n      } else {\n        var format = index.autoDetectFormat(data);\n        if (!format) {\n          throw new Error(\"Unrecognized data format for font.\");\n        }\n        fontData = format.parse(data);\n      }\n      if (textures instanceof core.Texture) {\n        textures = [textures];\n      }\n      var font = new _BitmapFont(fontData, textures, ownsTextures);\n      _BitmapFont.available[font.font] = font;\n      return font;\n    }\n  }, {\n    key: \"uninstall\",\n    value: function uninstall(name) {\n      var font = _BitmapFont.available[name];\n      if (!font) {\n        throw new Error(\"No font found named '\".concat(name, \"'\"));\n      }\n      font.destroy();\n      delete _BitmapFont.available[name];\n    }\n  }, {\n    key: \"from\",\n    value: function from(name, textStyle, options) {\n      if (!name) {\n        throw new Error(\"[BitmapFont] Property `name` is required.\");\n      }\n      var _Object$assign = Object.assign({}, _BitmapFont.defaultOptions, options),\n        chars = _Object$assign.chars,\n        padding = _Object$assign.padding,\n        resolution = _Object$assign.resolution,\n        textureWidth = _Object$assign.textureWidth,\n        textureHeight = _Object$assign.textureHeight,\n        baseOptions = _objectWithoutProperties(_Object$assign, [\"chars\", \"padding\", \"resolution\", \"textureWidth\", \"textureHeight\"]);\n      var charsList = resolveCharacters.resolveCharacters(chars);\n      var style = textStyle instanceof text.TextStyle ? textStyle : new text.TextStyle(textStyle);\n      var lineWidth = textureWidth;\n      var fontData = new BitmapFontData.BitmapFontData();\n      fontData.info[0] = {\n        face: style.fontFamily,\n        size: style.fontSize\n      };\n      fontData.common[0] = {\n        lineHeight: style.fontSize\n      };\n      var positionX = 0;\n      var positionY = 0;\n      var canvas;\n      var context;\n      var baseTexture;\n      var maxCharHeight = 0;\n      var baseTextures = [];\n      var textures = [];\n      for (var i = 0; i < charsList.length; i++) {\n        if (!canvas) {\n          canvas = core.settings.ADAPTER.createCanvas();\n          canvas.width = textureWidth;\n          canvas.height = textureHeight;\n          context = canvas.getContext(\"2d\");\n          baseTexture = new core.BaseTexture(canvas, _objectSpread({\n            resolution: resolution\n          }, baseOptions));\n          baseTextures.push(baseTexture);\n          textures.push(new core.Texture(baseTexture));\n          fontData.page.push({\n            id: textures.length - 1,\n            file: \"\"\n          });\n        }\n        var character = charsList[i];\n        var metrics = text.TextMetrics.measureText(character, style, false, canvas);\n        var width = metrics.width;\n        var height = Math.ceil(metrics.height);\n        var textureGlyphWidth = Math.ceil((style.fontStyle === \"italic\" ? 2 : 1) * width);\n        if (positionY >= textureHeight - height * resolution) {\n          if (positionY === 0) {\n            throw new Error(\"[BitmapFont] textureHeight \".concat(textureHeight, \"px is too small (fontFamily: '\").concat(style.fontFamily, \"', fontSize: \").concat(style.fontSize, \"px, char: '\").concat(character, \"')\"));\n          }\n          --i;\n          canvas = null;\n          context = null;\n          baseTexture = null;\n          positionY = 0;\n          positionX = 0;\n          maxCharHeight = 0;\n          continue;\n        }\n        maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);\n        if (textureGlyphWidth * resolution + positionX >= lineWidth) {\n          if (positionX === 0) {\n            throw new Error(\"[BitmapFont] textureWidth \".concat(textureWidth, \"px is too small (fontFamily: '\").concat(style.fontFamily, \"', fontSize: \").concat(style.fontSize, \"px, char: '\").concat(character, \"')\"));\n          }\n          --i;\n          positionY += maxCharHeight * resolution;\n          positionY = Math.ceil(positionY);\n          positionX = 0;\n          maxCharHeight = 0;\n          continue;\n        }\n        drawGlyph.drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);\n        var id = extractCharCode.extractCharCode(metrics.text);\n        fontData.char.push({\n          id: id,\n          page: textures.length - 1,\n          x: positionX / resolution,\n          y: positionY / resolution,\n          width: textureGlyphWidth,\n          height: height,\n          xoffset: 0,\n          yoffset: 0,\n          xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))\n        });\n        positionX += (textureGlyphWidth + 2 * padding) * resolution;\n        positionX = Math.ceil(positionX);\n      }\n      for (var _i3 = 0, len = charsList.length; _i3 < len; _i3++) {\n        var first = charsList[_i3];\n        for (var j = 0; j < len; j++) {\n          var second = charsList[j];\n          var c1 = context.measureText(first).width;\n          var c2 = context.measureText(second).width;\n          var total = context.measureText(first + second).width;\n          var amount = total - (c1 + c2);\n          if (amount) {\n            fontData.kerning.push({\n              first: extractCharCode.extractCharCode(first),\n              second: extractCharCode.extractCharCode(second),\n              amount: amount\n            });\n          }\n        }\n      }\n      var font = new _BitmapFont(fontData, textures, true);\n      if (_BitmapFont.available[name] !== void 0) {\n        _BitmapFont.uninstall(name);\n      }\n      _BitmapFont.available[name] = font;\n      return font;\n    }\n  }]);\n  return _BitmapFont;\n}();\nvar BitmapFont = _BitmapFont;\nBitmapFont.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"];\nBitmapFont.NUMERIC = [[\"0\", \"9\"]];\nBitmapFont.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"];\nBitmapFont.ASCII = [[\" \", \"~\"]];\nBitmapFont.defaultOptions = {\n  resolution: 1,\n  textureWidth: 512,\n  textureHeight: 512,\n  padding: 4,\n  chars: _BitmapFont.ALPHANUMERIC\n};\nBitmapFont.available = {};\nexports.BitmapFont = BitmapFont;","map":null,"metadata":{},"sourceType":"script"}