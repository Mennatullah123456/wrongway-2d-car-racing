{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar constants = require('@pixi/constants');\nrequire('../settings.js');\nvar extensions = require('@pixi/extensions');\nvar settings = require('@pixi/settings');\nvar byteSizeMap = {\n  5126: 4,\n  5123: 2,\n  5121: 1\n};\nvar GeometrySystem = /*#__PURE__*/function () {\n  function GeometrySystem(renderer) {\n    _classCallCheck(this, GeometrySystem);\n    this.renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n    this.canUseUInt32ElementIndex = false;\n    this.managedGeometries = {};\n  }\n  _createClass(GeometrySystem, [{\n    key: \"contextChange\",\n    value: function contextChange() {\n      this.disposeAll(true);\n      var gl = this.gl = this.renderer.gl;\n      var context = this.renderer.context;\n      this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n      if (context.webGLVersion !== 2) {\n        var nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n        if (settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {\n          nativeVaoExtension = null;\n        }\n        if (nativeVaoExtension) {\n          gl.createVertexArray = function () {\n            return nativeVaoExtension.createVertexArrayOES();\n          };\n          gl.bindVertexArray = function (vao) {\n            return nativeVaoExtension.bindVertexArrayOES(vao);\n          };\n          gl.deleteVertexArray = function (vao) {\n            return nativeVaoExtension.deleteVertexArrayOES(vao);\n          };\n        } else {\n          this.hasVao = false;\n          gl.createVertexArray = function () {\n            return null;\n          };\n          gl.bindVertexArray = function () {\n            return null;\n          };\n          gl.deleteVertexArray = function () {\n            return null;\n          };\n        }\n      }\n      if (context.webGLVersion !== 2) {\n        var instanceExt = gl.getExtension(\"ANGLE_instanced_arrays\");\n        if (instanceExt) {\n          gl.vertexAttribDivisor = function (a, b) {\n            return instanceExt.vertexAttribDivisorANGLE(a, b);\n          };\n          gl.drawElementsInstanced = function (a, b, c, d, e) {\n            return instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n          };\n          gl.drawArraysInstanced = function (a, b, c, d) {\n            return instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n          };\n        } else {\n          this.hasInstance = false;\n        }\n      }\n      this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(geometry, shader) {\n      shader = shader || this.renderer.shader.shader;\n      var gl = this.gl;\n      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n      var incRefCount = false;\n      if (!vaos) {\n        this.managedGeometries[geometry.id] = geometry;\n        geometry.disposeRunner.add(this);\n        geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n        incRefCount = true;\n      }\n      var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n      this._activeGeometry = geometry;\n      if (this._activeVao !== vao) {\n        this._activeVao = vao;\n        if (this.hasVao) {\n          gl.bindVertexArray(vao);\n        } else {\n          this.activateVao(geometry, shader.program);\n        }\n      }\n      this.updateBuffers();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.unbind();\n    }\n  }, {\n    key: \"updateBuffers\",\n    value: function updateBuffers() {\n      var geometry = this._activeGeometry;\n      var bufferSystem = this.renderer.buffer;\n      for (var i = 0; i < geometry.buffers.length; i++) {\n        var buffer = geometry.buffers[i];\n        bufferSystem.update(buffer);\n      }\n    }\n  }, {\n    key: \"checkCompatibility\",\n    value: function checkCompatibility(geometry, program) {\n      var geometryAttributes = geometry.attributes;\n      var shaderAttributes = program.attributeData;\n      for (var j in shaderAttributes) {\n        if (!geometryAttributes[j]) {\n          throw new Error(\"shader and geometry incompatible, geometry missing the \\\"\".concat(j, \"\\\" attribute\"));\n        }\n      }\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature(geometry, program) {\n      var attribs = geometry.attributes;\n      var shaderAttributes = program.attributeData;\n      var strings = [\"g\", geometry.id];\n      for (var i in attribs) {\n        if (shaderAttributes[i]) {\n          strings.push(i, shaderAttributes[i].location);\n        }\n      }\n      return strings.join(\"-\");\n    }\n  }, {\n    key: \"initGeometryVao\",\n    value: function initGeometryVao(geometry, shader) {\n      var incRefCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var gl = this.gl;\n      var CONTEXT_UID = this.CONTEXT_UID;\n      var bufferSystem = this.renderer.buffer;\n      var program = shader.program;\n      if (!program.glPrograms[CONTEXT_UID]) {\n        this.renderer.shader.generateProgram(shader);\n      }\n      this.checkCompatibility(geometry, program);\n      var signature = this.getSignature(geometry, program);\n      var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n      var vao = vaoObjectHash[signature];\n      if (vao) {\n        vaoObjectHash[program.id] = vao;\n        return vao;\n      }\n      var buffers = geometry.buffers;\n      var attributes = geometry.attributes;\n      var tempStride = {};\n      var tempStart = {};\n      for (var j in buffers) {\n        tempStride[j] = 0;\n        tempStart[j] = 0;\n      }\n      for (var _j in attributes) {\n        if (!attributes[_j].size && program.attributeData[_j]) {\n          attributes[_j].size = program.attributeData[_j].size;\n        } else if (!attributes[_j].size) {\n          console.warn(\"PIXI Geometry attribute '\".concat(_j, \"' size cannot be determined (likely the bound shader does not have the attribute)\"));\n        }\n        tempStride[attributes[_j].buffer] += attributes[_j].size * byteSizeMap[attributes[_j].type];\n      }\n      for (var _j2 in attributes) {\n        var attribute = attributes[_j2];\n        var attribSize = attribute.size;\n        if (attribute.stride === void 0) {\n          if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {\n            attribute.stride = 0;\n          } else {\n            attribute.stride = tempStride[attribute.buffer];\n          }\n        }\n        if (attribute.start === void 0) {\n          attribute.start = tempStart[attribute.buffer];\n          tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n        }\n      }\n      vao = gl.createVertexArray();\n      gl.bindVertexArray(vao);\n      for (var i = 0; i < buffers.length; i++) {\n        var buffer = buffers[i];\n        bufferSystem.bind(buffer);\n        if (incRefCount) {\n          buffer._glBuffers[CONTEXT_UID].refCount++;\n        }\n      }\n      this.activateVao(geometry, program);\n      vaoObjectHash[program.id] = vao;\n      vaoObjectHash[signature] = vao;\n      gl.bindVertexArray(null);\n      bufferSystem.unbind(constants.BUFFER_TYPE.ARRAY_BUFFER);\n      return vao;\n    }\n  }, {\n    key: \"disposeGeometry\",\n    value: function disposeGeometry(geometry, contextLost) {\n      if (!this.managedGeometries[geometry.id]) {\n        return;\n      }\n      delete this.managedGeometries[geometry.id];\n      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n      var gl = this.gl;\n      var buffers = geometry.buffers;\n      var bufferSystem = this.renderer?.buffer;\n      geometry.disposeRunner.remove(this);\n      if (!vaos) {\n        return;\n      }\n      if (bufferSystem) {\n        for (var i = 0; i < buffers.length; i++) {\n          var buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n          if (buf) {\n            buf.refCount--;\n            if (buf.refCount === 0 && !contextLost) {\n              bufferSystem.dispose(buffers[i], contextLost);\n            }\n          }\n        }\n      }\n      if (!contextLost) {\n        for (var vaoId in vaos) {\n          if (vaoId[0] === \"g\") {\n            var vao = vaos[vaoId];\n            if (this._activeVao === vao) {\n              this.unbind();\n            }\n            gl.deleteVertexArray(vao);\n          }\n        }\n      }\n      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    }\n  }, {\n    key: \"disposeAll\",\n    value: function disposeAll(contextLost) {\n      var all = Object.keys(this.managedGeometries);\n      for (var i = 0; i < all.length; i++) {\n        this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n      }\n    }\n  }, {\n    key: \"activateVao\",\n    value: function activateVao(geometry, program) {\n      var gl = this.gl;\n      var CONTEXT_UID = this.CONTEXT_UID;\n      var bufferSystem = this.renderer.buffer;\n      var buffers = geometry.buffers;\n      var attributes = geometry.attributes;\n      if (geometry.indexBuffer) {\n        bufferSystem.bind(geometry.indexBuffer);\n      }\n      var lastBuffer = null;\n      for (var j in attributes) {\n        var attribute = attributes[j];\n        var buffer = buffers[attribute.buffer];\n        var glBuffer = buffer._glBuffers[CONTEXT_UID];\n        if (program.attributeData[j]) {\n          if (lastBuffer !== glBuffer) {\n            bufferSystem.bind(buffer);\n            lastBuffer = glBuffer;\n          }\n          var location = program.attributeData[j].location;\n          gl.enableVertexAttribArray(location);\n          gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);\n          if (attribute.instance) {\n            if (this.hasInstance) {\n              gl.vertexAttribDivisor(location, 1);\n            } else {\n              throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(type, size, start, instanceCount) {\n      var gl = this.gl;\n      var geometry = this._activeGeometry;\n      if (geometry.indexBuffer) {\n        var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n        if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {\n          if (geometry.instanced) {\n            gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n          } else {\n            gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n          }\n        } else {\n          console.warn(\"unsupported index buffer type: uint32\");\n        }\n      } else if (geometry.instanced) {\n        gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n      } else {\n        gl.drawArrays(type, start, size || geometry.getSize());\n      }\n      return this;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.gl.bindVertexArray(null);\n      this._activeVao = null;\n      this._activeGeometry = null;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n    }\n  }]);\n  return GeometrySystem;\n}();\nGeometrySystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"geometry\"\n};\nextensions.extensions.add(GeometrySystem);\nexports.GeometrySystem = GeometrySystem;","map":null,"metadata":{},"sourceType":"script"}