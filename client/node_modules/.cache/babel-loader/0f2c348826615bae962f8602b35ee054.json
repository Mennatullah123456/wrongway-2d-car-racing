{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { EventEmitter, uid, isPow2, BaseTextureCache, TextureCache } from '@pixi/utils';\nimport { SCALE_MODES, FORMATS, ALPHA_MODES, TYPES, TARGETS } from '@pixi/constants';\nimport { Resource } from './resources/Resource.mjs';\nimport { BufferResource } from './resources/BufferResource.mjs';\nimport { autoDetectResource } from './resources/autoDetectResource.mjs';\nimport { settings } from '@pixi/settings';\nvar defaultBufferOptions = {\n  scaleMode: SCALE_MODES.NEAREST,\n  format: FORMATS.RGBA,\n  alphaMode: ALPHA_MODES.NPM\n};\nvar _BaseTexture = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(_BaseTexture, _EventEmitter);\n  function _BaseTexture() {\n    var _this;\n    var resource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, _BaseTexture);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_BaseTexture).call(this));\n    options = options || {};\n    var _options = options,\n      alphaMode = _options.alphaMode,\n      mipmap = _options.mipmap,\n      anisotropicLevel = _options.anisotropicLevel,\n      scaleMode = _options.scaleMode,\n      width = _options.width,\n      height = _options.height,\n      wrapMode = _options.wrapMode,\n      format = _options.format,\n      type = _options.type,\n      target = _options.target,\n      resolution = _options.resolution,\n      resourceOptions = _options.resourceOptions;\n    if (resource && !(resource instanceof Resource)) {\n      resource = autoDetectResource(resource, resourceOptions);\n      resource.internal = true;\n    }\n    _this.resolution = resolution || settings.RESOLUTION;\n    _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;\n    _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;\n    _this._mipmap = mipmap ?? settings.MIPMAP_TEXTURES;\n    _this.anisotropicLevel = anisotropicLevel ?? settings.ANISOTROPIC_LEVEL;\n    _this._wrapMode = wrapMode || settings.WRAP_MODE;\n    _this._scaleMode = scaleMode ?? settings.SCALE_MODE;\n    _this.format = format || FORMATS.RGBA;\n    _this.type = type || TYPES.UNSIGNED_BYTE;\n    _this.target = target || TARGETS.TEXTURE_2D;\n    _this.alphaMode = alphaMode ?? ALPHA_MODES.UNPACK;\n    _this.uid = uid();\n    _this.touched = 0;\n    _this.isPowerOfTwo = false;\n    _this._refreshPOT();\n    _this._glTextures = {};\n    _this.dirtyId = 0;\n    _this.dirtyStyleId = 0;\n    _this.cacheId = null;\n    _this.valid = width > 0 && height > 0;\n    _this.textureCacheIds = [];\n    _this.destroyed = false;\n    _this.resource = null;\n    _this._batchEnabled = 0;\n    _this._batchLocation = 0;\n    _this.parentTextureArray = null;\n    _this.setResource(resource);\n    return _this;\n  }\n  _createClass(_BaseTexture, [{\n    key: \"setStyle\",\n    value: function setStyle(scaleMode, mipmap) {\n      var dirty;\n      if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {\n        this.scaleMode = scaleMode;\n        dirty = true;\n      }\n      if (mipmap !== void 0 && mipmap !== this.mipmap) {\n        this.mipmap = mipmap;\n        dirty = true;\n      }\n      if (dirty) {\n        this.dirtyStyleId++;\n      }\n      return this;\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(desiredWidth, desiredHeight, resolution) {\n      resolution = resolution || this.resolution;\n      return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);\n    }\n  }, {\n    key: \"setRealSize\",\n    value: function setRealSize(realWidth, realHeight, resolution) {\n      this.resolution = resolution || this.resolution;\n      this.width = Math.round(realWidth) / this.resolution;\n      this.height = Math.round(realHeight) / this.resolution;\n      this._refreshPOT();\n      this.update();\n      return this;\n    }\n  }, {\n    key: \"_refreshPOT\",\n    value: function _refreshPOT() {\n      this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);\n    }\n  }, {\n    key: \"setResolution\",\n    value: function setResolution(resolution) {\n      var oldResolution = this.resolution;\n      if (oldResolution === resolution) {\n        return this;\n      }\n      this.resolution = resolution;\n      if (this.valid) {\n        this.width = Math.round(this.width * oldResolution) / resolution;\n        this.height = Math.round(this.height * oldResolution) / resolution;\n        this.emit(\"update\", this);\n      }\n      this._refreshPOT();\n      return this;\n    }\n  }, {\n    key: \"setResource\",\n    value: function setResource(resource) {\n      if (this.resource === resource) {\n        return this;\n      }\n      if (this.resource) {\n        throw new Error(\"Resource can be set only once\");\n      }\n      resource.bind(this);\n      this.resource = resource;\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (!this.valid) {\n        if (this.width > 0 && this.height > 0) {\n          this.valid = true;\n          this.emit(\"loaded\", this);\n          this.emit(\"update\", this);\n        }\n      } else {\n        this.dirtyId++;\n        this.dirtyStyleId++;\n        this.emit(\"update\", this);\n      }\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(event) {\n      this.emit(\"error\", this, event);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.resource) {\n        this.resource.unbind(this);\n        if (this.resource.internal) {\n          this.resource.destroy();\n        }\n        this.resource = null;\n      }\n      if (this.cacheId) {\n        delete BaseTextureCache[this.cacheId];\n        delete TextureCache[this.cacheId];\n        this.cacheId = null;\n      }\n      this.dispose();\n      _BaseTexture.removeFromCache(this);\n      this.textureCacheIds = null;\n      this.destroyed = true;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.emit(\"dispose\", this);\n    }\n  }, {\n    key: \"castToBaseTexture\",\n    value: function castToBaseTexture() {\n      return this;\n    }\n  }, {\n    key: \"realWidth\",\n    get: function get() {\n      return Math.round(this.width * this.resolution);\n    }\n  }, {\n    key: \"realHeight\",\n    get: function get() {\n      return Math.round(this.height * this.resolution);\n    }\n  }, {\n    key: \"mipmap\",\n    get: function get() {\n      return this._mipmap;\n    },\n    set: function set(value) {\n      if (this._mipmap !== value) {\n        this._mipmap = value;\n        this.dirtyStyleId++;\n      }\n    }\n  }, {\n    key: \"scaleMode\",\n    get: function get() {\n      return this._scaleMode;\n    },\n    set: function set(value) {\n      if (this._scaleMode !== value) {\n        this._scaleMode = value;\n        this.dirtyStyleId++;\n      }\n    }\n  }, {\n    key: \"wrapMode\",\n    get: function get() {\n      return this._wrapMode;\n    },\n    set: function set(value) {\n      if (this._wrapMode !== value) {\n        this._wrapMode = value;\n        this.dirtyStyleId++;\n      }\n    }\n  }], [{\n    key: \"from\",\n    value: function from(source, options) {\n      var strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : settings.STRICT_TEXTURE_CACHE;\n      var isFrame = typeof source === \"string\";\n      var cacheId = null;\n      if (isFrame) {\n        cacheId = source;\n      } else {\n        if (!source._pixiId) {\n          var prefix = options?.pixiIdPrefix || \"pixiid\";\n          source._pixiId = \"\".concat(prefix, \"_\").concat(uid());\n        }\n        cacheId = source._pixiId;\n      }\n      var baseTexture = BaseTextureCache[cacheId];\n      if (isFrame && strict && !baseTexture) {\n        throw new Error(\"The cacheId \\\"\".concat(cacheId, \"\\\" does not exist in BaseTextureCache.\"));\n      }\n      if (!baseTexture) {\n        baseTexture = new _BaseTexture(source, options);\n        baseTexture.cacheId = cacheId;\n        _BaseTexture.addToCache(baseTexture, cacheId);\n      }\n      return baseTexture;\n    }\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(buffer, width, height, options) {\n      buffer = buffer || new Float32Array(width * height * 4);\n      var resource = new BufferResource(buffer, {\n        width: width,\n        height: height\n      });\n      var type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;\n      return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, options || {\n        width: width,\n        height: height,\n        type: type\n      }));\n    }\n  }, {\n    key: \"addToCache\",\n    value: function addToCache(baseTexture, id) {\n      if (id) {\n        if (!baseTexture.textureCacheIds.includes(id)) {\n          baseTexture.textureCacheIds.push(id);\n        }\n        if (BaseTextureCache[id] && BaseTextureCache[id] !== baseTexture) {\n          console.warn(\"BaseTexture added to the cache with an id [\".concat(id, \"] that already had an entry\"));\n        }\n        BaseTextureCache[id] = baseTexture;\n      }\n    }\n  }, {\n    key: \"removeFromCache\",\n    value: function removeFromCache(baseTexture) {\n      if (typeof baseTexture === \"string\") {\n        var baseTextureFromCache = BaseTextureCache[baseTexture];\n        if (baseTextureFromCache) {\n          var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n          if (index > -1) {\n            baseTextureFromCache.textureCacheIds.splice(index, 1);\n          }\n          delete BaseTextureCache[baseTexture];\n          return baseTextureFromCache;\n        }\n      } else if (baseTexture?.textureCacheIds) {\n        for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {\n          delete BaseTextureCache[baseTexture.textureCacheIds[i]];\n        }\n        baseTexture.textureCacheIds.length = 0;\n        return baseTexture;\n      }\n      return null;\n    }\n  }]);\n  return _BaseTexture;\n}(EventEmitter);\nvar BaseTexture = _BaseTexture;\nBaseTexture._globalBatch = 0;\nexport { BaseTexture };","map":null,"metadata":{},"sourceType":"module"}