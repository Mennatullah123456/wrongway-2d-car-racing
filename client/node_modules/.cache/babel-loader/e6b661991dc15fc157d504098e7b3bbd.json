{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport './utils/index.mjs';\nimport { generateUniformBufferSync } from './utils/generateUniformBufferSync.mjs';\nimport { generateProgram as _generateProgram } from './utils/generateProgram.mjs';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { unsafeEvalSupported } from './utils/unsafeEvalSupported.mjs';\nimport { generateUniformsSync } from './utils/generateUniformsSync.mjs';\nvar UID = 0;\nvar defaultSyncData = {\n  textureCount: 0,\n  uboCount: 0\n};\nvar ShaderSystem = /*#__PURE__*/function () {\n  function ShaderSystem(renderer) {\n    _classCallCheck(this, ShaderSystem);\n    this.destroyed = false;\n    this.renderer = renderer;\n    this.systemCheck();\n    this.gl = null;\n    this.shader = null;\n    this.program = null;\n    this.cache = {};\n    this._uboCache = {};\n    this.id = UID++;\n  }\n  _createClass(ShaderSystem, [{\n    key: \"systemCheck\",\n    value: function systemCheck() {\n      if (!unsafeEvalSupported()) {\n        throw new Error(\"Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.\");\n      }\n    }\n  }, {\n    key: \"contextChange\",\n    value: function contextChange(gl) {\n      this.gl = gl;\n      this.reset();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(shader, dontSync) {\n      shader.disposeRunner.add(this);\n      shader.uniforms.globals = this.renderer.globalUniforms;\n      var program = shader.program;\n      var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);\n      this.shader = shader;\n      if (this.program !== program) {\n        this.program = program;\n        this.gl.useProgram(glProgram.program);\n      }\n      if (!dontSync) {\n        defaultSyncData.textureCount = 0;\n        defaultSyncData.uboCount = 0;\n        this.syncUniformGroup(shader.uniformGroup, defaultSyncData);\n      }\n      return glProgram;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(uniforms) {\n      var shader = this.shader.program;\n      var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];\n      shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);\n    }\n  }, {\n    key: \"syncUniformGroup\",\n    value: function syncUniformGroup(group, syncData) {\n      var glProgram = this.getGlProgram();\n      if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {\n        glProgram.uniformDirtyGroups[group.id] = group.dirtyId;\n        this.syncUniforms(group, glProgram, syncData);\n      }\n    }\n  }, {\n    key: \"syncUniforms\",\n    value: function syncUniforms(group, glProgram, syncData) {\n      var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);\n      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);\n    }\n  }, {\n    key: \"createSyncGroups\",\n    value: function createSyncGroups(group) {\n      var id = this.getSignature(group, this.shader.program.uniformData, \"u\");\n      if (!this.cache[id]) {\n        this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);\n      }\n      group.syncUniforms[this.shader.program.id] = this.cache[id];\n      return group.syncUniforms[this.shader.program.id];\n    }\n  }, {\n    key: \"syncUniformBufferGroup\",\n    value: function syncUniformBufferGroup(group, name) {\n      var glProgram = this.getGlProgram();\n      if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {\n        group.dirtyId = 0;\n        var syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);\n        group.buffer.update();\n        syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);\n      }\n      this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);\n    }\n  }, {\n    key: \"createSyncBufferGroup\",\n    value: function createSyncBufferGroup(group, glProgram, name) {\n      var gl = this.renderer.gl;\n      this.renderer.buffer.bind(group.buffer);\n      var uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);\n      glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;\n      gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);\n      this.shader.uniformBindCount++;\n      var id = this.getSignature(group, this.shader.program.uniformData, \"ubo\");\n      var uboData = this._uboCache[id];\n      if (!uboData) {\n        uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);\n      }\n      if (group.autoManage) {\n        var data = new Float32Array(uboData.size / 4);\n        group.buffer.update(data);\n      }\n      glProgram.uniformGroups[group.id] = uboData.syncFunc;\n      return glProgram.uniformGroups[group.id];\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature(group, uniformData, preFix) {\n      var uniforms = group.uniforms;\n      var strings = [\"\".concat(preFix, \"-\")];\n      for (var i in uniforms) {\n        strings.push(i);\n        if (uniformData[i]) {\n          strings.push(uniformData[i].type);\n        }\n      }\n      return strings.join(\"-\");\n    }\n  }, {\n    key: \"getGlProgram\",\n    value: function getGlProgram() {\n      if (this.shader) {\n        return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];\n      }\n      return null;\n    }\n  }, {\n    key: \"generateProgram\",\n    value: function generateProgram(shader) {\n      var gl = this.gl;\n      var program = shader.program;\n      var glProgram = _generateProgram(gl, program);\n      program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;\n      return glProgram;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.program = null;\n      this.shader = null;\n    }\n  }, {\n    key: \"disposeShader\",\n    value: function disposeShader(shader) {\n      if (this.shader === shader) {\n        this.shader = null;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n      this.destroyed = true;\n    }\n  }]);\n  return ShaderSystem;\n}();\nShaderSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"shader\"\n};\nextensions.add(ShaderSystem);\nexport { ShaderSystem };","map":null,"metadata":{},"sourceType":"module"}