{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar spriteTilingSimple = require('./sprite-tiling-simple.js');\nvar spriteTilingFallback = require('./sprite-tiling-fallback.js');\nvar spriteTilingFallback$1 = require('./sprite-tiling-fallback2.js');\nvar spriteTiling = require('./sprite-tiling.js');\nvar spriteTiling$1 = require('./sprite-tiling2.js');\nvar tempMat = new core.Matrix();\nvar TilingSpriteRenderer = /*#__PURE__*/function (_core$ObjectRenderer) {\n  _inherits(TilingSpriteRenderer, _core$ObjectRenderer);\n  function TilingSpriteRenderer(renderer) {\n    var _this;\n    _classCallCheck(this, TilingSpriteRenderer);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TilingSpriteRenderer).call(this, renderer));\n    renderer.runners.contextChange.add(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.quad = new core.QuadUv();\n    _this.state = core.State.for2d();\n    return _this;\n  }\n  _createClass(TilingSpriteRenderer, [{\n    key: \"contextChange\",\n    value: function contextChange() {\n      var renderer = this.renderer;\n      var uniforms = {\n        globals: renderer.globalUniforms\n      };\n      this.simpleShader = core.Shader.from(spriteTilingFallback[\"default\"], spriteTilingSimple[\"default\"], uniforms);\n      this.shader = renderer.context.webGLVersion > 1 ? core.Shader.from(spriteTiling[\"default\"], spriteTiling$1[\"default\"], uniforms) : core.Shader.from(spriteTilingFallback[\"default\"], spriteTilingFallback$1[\"default\"], uniforms);\n    }\n  }, {\n    key: \"render\",\n    value: function render(ts) {\n      var renderer = this.renderer;\n      var quad = this.quad;\n      var vertices = quad.vertices;\n      vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n      vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n      vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);\n      vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);\n      var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n      var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n      vertices = quad.uvs;\n      vertices[0] = vertices[6] = -anchorX;\n      vertices[1] = vertices[3] = -anchorY;\n      vertices[2] = vertices[4] = 1 - anchorX;\n      vertices[5] = vertices[7] = 1 - anchorY;\n      quad.invalidate();\n      var tex = ts._texture;\n      var baseTex = tex.baseTexture;\n      var premultiplied = baseTex.alphaMode > 0;\n      var lt = ts.tileTransform.localTransform;\n      var uv = ts.uvMatrix;\n      var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n      if (isSimple) {\n        if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n          if (baseTex.wrapMode === core.WRAP_MODES.CLAMP) {\n            baseTex.wrapMode = core.WRAP_MODES.REPEAT;\n          }\n        } else {\n          isSimple = baseTex.wrapMode !== core.WRAP_MODES.CLAMP;\n        }\n      }\n      var shader = isSimple ? this.simpleShader : this.shader;\n      var w = tex.width;\n      var h = tex.height;\n      var W = ts._width;\n      var H = ts._height;\n      tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n      tempMat.invert();\n      if (isSimple) {\n        tempMat.prepend(uv.mapCoord);\n      } else {\n        shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n        shader.uniforms.uClampFrame = uv.uClampFrame;\n        shader.uniforms.uClampOffset = uv.uClampOffset;\n      }\n      shader.uniforms.uTransform = tempMat.toArray(true);\n      shader.uniforms.uColor = core.utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, premultiplied);\n      shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n      shader.uniforms.uSampler = tex;\n      renderer.shader.bind(shader);\n      renderer.geometry.bind(quad);\n      this.state.blendMode = core.utils.correctBlendMode(ts.blendMode, premultiplied);\n      renderer.state.set(this.state);\n      renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n  }]);\n  return TilingSpriteRenderer;\n}(core.ObjectRenderer);\nTilingSpriteRenderer.extension = {\n  name: \"tilingSprite\",\n  type: core.ExtensionType.RendererPlugin\n};\ncore.extensions.add(TilingSpriteRenderer);\nexports.TilingSpriteRenderer = TilingSpriteRenderer;","map":null,"metadata":{},"sourceType":"script"}