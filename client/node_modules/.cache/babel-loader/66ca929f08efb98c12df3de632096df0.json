{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar FederatedMouseEvent = require('./FederatedMouseEvent.js');\nvar FederatedPointerEvent = require('./FederatedPointerEvent.js');\nvar FederatedWheelEvent = require('./FederatedWheelEvent.js');\nvar core = require('@pixi/core');\nvar PROPAGATION_LIMIT = 2048;\nvar tempHitLocation = new core.Point();\nvar tempLocalMapping = new core.Point();\nvar EventBoundary = /*#__PURE__*/function () {\n  function EventBoundary(rootTarget) {\n    _classCallCheck(this, EventBoundary);\n    this.dispatch = new core.utils.EventEmitter();\n    this.moveOnAll = false;\n    this.mappingState = {\n      trackingData: {}\n    };\n    this.eventPool = /* @__PURE__ */new Map();\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping(\"pointerdown\", this.mapPointerDown);\n    this.addEventMapping(\"pointermove\", this.mapPointerMove);\n    this.addEventMapping(\"pointerout\", this.mapPointerOut);\n    this.addEventMapping(\"pointerleave\", this.mapPointerOut);\n    this.addEventMapping(\"pointerover\", this.mapPointerOver);\n    this.addEventMapping(\"pointerup\", this.mapPointerUp);\n    this.addEventMapping(\"pointerupoutside\", this.mapPointerUpOutside);\n    this.addEventMapping(\"wheel\", this.mapWheel);\n  }\n  _createClass(EventBoundary, [{\n    key: \"addEventMapping\",\n    value: function addEventMapping(type, fn) {\n      if (!this.mappingTable[type]) {\n        this.mappingTable[type] = [];\n      }\n      this.mappingTable[type].push({\n        fn: fn,\n        priority: 0\n      });\n      this.mappingTable[type].sort(function (a, b) {\n        return a.priority - b.priority;\n      });\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(e, type) {\n      e.propagationStopped = false;\n      e.propagationImmediatelyStopped = false;\n      this.propagate(e, type);\n      this.dispatch.emit(type || e.type, e);\n    }\n  }, {\n    key: \"mapEvent\",\n    value: function mapEvent(e) {\n      if (!this.rootTarget) {\n        return;\n      }\n      var mappers = this.mappingTable[e.type];\n      if (mappers) {\n        for (var i = 0, j = mappers.length; i < j; i++) {\n          mappers[i].fn(e);\n        }\n      } else {\n        console.warn(\"[EventBoundary]: Event mapping not defined for \".concat(e.type));\n      }\n    }\n  }, {\n    key: \"hitTest\",\n    value: function hitTest(x, y) {\n      var invertedPath = this.hitTestRecursive(this.rootTarget, this.rootTarget.interactive, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);\n      return invertedPath && invertedPath[0];\n    }\n  }, {\n    key: \"propagate\",\n    value: function propagate(e, type) {\n      if (!e.target) {\n        return;\n      }\n      var composedPath = e.composedPath();\n      e.eventPhase = e.CAPTURING_PHASE;\n      for (var i = 0, j = composedPath.length - 1; i < j; i++) {\n        e.currentTarget = composedPath[i];\n        this.notifyTarget(e, type);\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n      }\n      e.eventPhase = e.AT_TARGET;\n      e.currentTarget = e.target;\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n      e.eventPhase = e.BUBBLING_PHASE;\n      for (var _i = composedPath.length - 2; _i >= 0; _i--) {\n        e.currentTarget = composedPath[_i];\n        this.notifyTarget(e, type);\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n      }\n    }\n  }, {\n    key: \"all\",\n    value: function all(e, type) {\n      var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.rootTarget;\n      e.eventPhase = e.BUBBLING_PHASE;\n      var children = target.children;\n      if (children) {\n        for (var i = 0; i < children.length; i++) {\n          this.all(e, type, children[i]);\n        }\n      }\n      e.currentTarget = target;\n      this.notifyTarget(e, type);\n    }\n  }, {\n    key: \"propagationPath\",\n    value: function propagationPath(target) {\n      var propagationPath = [target];\n      for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {\n        if (!target.parent) {\n          throw new Error(\"Cannot find propagation path to disconnected target\");\n        }\n        propagationPath.push(target.parent);\n        target = target.parent;\n      }\n      propagationPath.reverse();\n      return propagationPath;\n    }\n  }, {\n    key: \"hitTestRecursive\",\n    value: function hitTestRecursive(currentTarget, interactive, location, testFn, pruneFn) {\n      if (!currentTarget || !currentTarget.visible) {\n        return null;\n      }\n      if (pruneFn(currentTarget, location)) {\n        return null;\n      }\n      if (currentTarget.interactiveChildren && currentTarget.children) {\n        var children = currentTarget.children;\n        for (var i = children.length - 1; i >= 0; i--) {\n          var child = children[i];\n          var nestedHit = this.hitTestRecursive(child, interactive || child.interactive, location, testFn, pruneFn);\n          if (nestedHit) {\n            if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n              continue;\n            }\n            if (nestedHit.length > 0 || currentTarget.interactive) {\n              nestedHit.push(currentTarget);\n            }\n            return nestedHit;\n          }\n        }\n      }\n      if (interactive && testFn(currentTarget, location)) {\n        return currentTarget.interactive ? [currentTarget] : [];\n      }\n      return null;\n    }\n  }, {\n    key: \"hitPruneFn\",\n    value: function hitPruneFn(displayObject, location) {\n      if (displayObject.hitArea) {\n        displayObject.worldTransform.applyInverse(location, tempLocalMapping);\n        if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n          return true;\n        }\n      }\n      if (displayObject._mask) {\n        var maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;\n        if (maskObject && !maskObject.containsPoint?.(location)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"hitTestFn\",\n    value: function hitTestFn(displayObject, location) {\n      if (displayObject.hitArea) {\n        return true;\n      }\n      if (displayObject.containsPoint) {\n        return displayObject.containsPoint(location);\n      }\n      return false;\n    }\n  }, {\n    key: \"notifyTarget\",\n    value: function notifyTarget(e, type) {\n      type = type ?? e.type;\n      var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? \"\".concat(type, \"capture\") : type;\n      this.notifyListeners(e, key);\n      if (e.eventPhase === e.AT_TARGET) {\n        this.notifyListeners(e, type);\n      }\n    }\n  }, {\n    key: \"mapPointerDown\",\n    value: function mapPointerDown(from) {\n      if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var e = this.createPointerEvent(from);\n      this.dispatchEvent(e, \"pointerdown\");\n      if (e.pointerType === \"touch\") {\n        this.dispatchEvent(e, \"touchstart\");\n      } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n        var isRightButton = e.button === 2;\n        this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n      }\n      var trackingData = this.trackingData(from.pointerId);\n      trackingData.pressTargetsByButton[from.button] = e.composedPath();\n      this.freeEvent(e);\n    }\n  }, {\n    key: \"mapPointerMove\",\n    value: function mapPointerMove(from) {\n      if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var e = this.createPointerEvent(from);\n      var isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n      var trackingData = this.trackingData(from.pointerId);\n      var outTarget = this.findMountedTarget(trackingData.overTargets);\n      if (trackingData.overTargets && outTarget !== e.target) {\n        var outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\";\n        var outEvent = this.createPointerEvent(from, outType, outTarget);\n        this.dispatchEvent(outEvent, \"pointerout\");\n        if (isMouse) this.dispatchEvent(outEvent, \"mouseout\");\n        if (!e.composedPath().includes(outTarget)) {\n          var leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n          leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n          while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n            leaveEvent.currentTarget = leaveEvent.target;\n            this.notifyTarget(leaveEvent);\n            if (isMouse) this.notifyTarget(leaveEvent, \"mouseleave\");\n            leaveEvent.target = leaveEvent.target.parent;\n          }\n          this.freeEvent(leaveEvent);\n        }\n        this.freeEvent(outEvent);\n      }\n      if (outTarget !== e.target) {\n        var overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\";\n        var overEvent = this.clonePointerEvent(e, overType);\n        this.dispatchEvent(overEvent, \"pointerover\");\n        if (isMouse) this.dispatchEvent(overEvent, \"mouseover\");\n        var overTargetAncestor = outTarget?.parent;\n        while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n          if (overTargetAncestor === e.target) break;\n          overTargetAncestor = overTargetAncestor.parent;\n        }\n        var didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n        if (didPointerEnter) {\n          var enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n          enterEvent.eventPhase = enterEvent.AT_TARGET;\n          while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n            enterEvent.currentTarget = enterEvent.target;\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, \"mouseenter\");\n            enterEvent.target = enterEvent.target.parent;\n          }\n          this.freeEvent(enterEvent);\n        }\n        this.freeEvent(overEvent);\n      }\n      var propagationMethod = this.moveOnAll ? \"all\" : \"dispatchEvent\";\n      this[propagationMethod](e, \"pointermove\");\n      if (e.pointerType === \"touch\") this[propagationMethod](e, \"touchmove\");\n      if (isMouse) {\n        this[propagationMethod](e, \"mousemove\");\n        this.cursor = e.target?.cursor;\n      }\n      trackingData.overTargets = e.composedPath();\n      this.freeEvent(e);\n    }\n  }, {\n    key: \"mapPointerOver\",\n    value: function mapPointerOver(from) {\n      if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var trackingData = this.trackingData(from.pointerId);\n      var e = this.createPointerEvent(from);\n      var isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n      this.dispatchEvent(e, \"pointerover\");\n      if (isMouse) this.dispatchEvent(e, \"mouseover\");\n      if (e.pointerType === \"mouse\") this.cursor = e.target?.cursor;\n      var enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n      enterEvent.eventPhase = enterEvent.AT_TARGET;\n      while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n        enterEvent.currentTarget = enterEvent.target;\n        this.notifyTarget(enterEvent);\n        if (isMouse) this.notifyTarget(enterEvent, \"mouseenter\");\n        enterEvent.target = enterEvent.target.parent;\n      }\n      trackingData.overTargets = e.composedPath();\n      this.freeEvent(e);\n      this.freeEvent(enterEvent);\n    }\n  }, {\n    key: \"mapPointerOut\",\n    value: function mapPointerOut(from) {\n      if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var trackingData = this.trackingData(from.pointerId);\n      if (trackingData.overTargets) {\n        var isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\";\n        var outTarget = this.findMountedTarget(trackingData.overTargets);\n        var outEvent = this.createPointerEvent(from, \"pointerout\", outTarget);\n        this.dispatchEvent(outEvent);\n        if (isMouse) this.dispatchEvent(outEvent, \"mouseout\");\n        var leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse) this.notifyTarget(leaveEvent, \"mouseleave\");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        trackingData.overTargets = null;\n        this.freeEvent(outEvent);\n        this.freeEvent(leaveEvent);\n      }\n      this.cursor = null;\n    }\n  }, {\n    key: \"mapPointerUp\",\n    value: function mapPointerUp(from) {\n      if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var now = performance.now();\n      var e = this.createPointerEvent(from);\n      this.dispatchEvent(e, \"pointerup\");\n      if (e.pointerType === \"touch\") {\n        this.dispatchEvent(e, \"touchend\");\n      } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n        var isRightButton = e.button === 2;\n        this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n      }\n      var trackingData = this.trackingData(from.pointerId);\n      var pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n      var clickTarget = pressTarget;\n      if (pressTarget && !e.composedPath().includes(pressTarget)) {\n        var currentTarget = pressTarget;\n        while (currentTarget && !e.composedPath().includes(currentTarget)) {\n          e.currentTarget = currentTarget;\n          this.notifyTarget(e, \"pointerupoutside\");\n          if (e.pointerType === \"touch\") {\n            this.notifyTarget(e, \"touchendoutside\");\n          } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n            var _isRightButton = e.button === 2;\n            this.notifyTarget(e, _isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n          }\n          currentTarget = currentTarget.parent;\n        }\n        delete trackingData.pressTargetsByButton[from.button];\n        clickTarget = currentTarget;\n      }\n      if (clickTarget) {\n        var clickEvent = this.clonePointerEvent(e, \"click\");\n        clickEvent.target = clickTarget;\n        clickEvent.path = null;\n        if (!trackingData.clicksByButton[from.button]) {\n          trackingData.clicksByButton[from.button] = {\n            clickCount: 0,\n            target: clickEvent.target,\n            timeStamp: now\n          };\n        }\n        var clickHistory = trackingData.clicksByButton[from.button];\n        if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n          ++clickHistory.clickCount;\n        } else {\n          clickHistory.clickCount = 1;\n        }\n        clickHistory.target = clickEvent.target;\n        clickHistory.timeStamp = now;\n        clickEvent.detail = clickHistory.clickCount;\n        if (clickEvent.pointerType === \"mouse\") {\n          this.dispatchEvent(clickEvent, \"click\");\n        } else if (clickEvent.pointerType === \"touch\") {\n          this.dispatchEvent(clickEvent, \"tap\");\n        }\n        this.dispatchEvent(clickEvent, \"pointertap\");\n        this.freeEvent(clickEvent);\n      }\n      this.freeEvent(e);\n    }\n  }, {\n    key: \"mapPointerUpOutside\",\n    value: function mapPointerUpOutside(from) {\n      if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var trackingData = this.trackingData(from.pointerId);\n      var pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n      var e = this.createPointerEvent(from);\n      if (pressTarget) {\n        var currentTarget = pressTarget;\n        while (currentTarget) {\n          e.currentTarget = currentTarget;\n          this.notifyTarget(e, \"pointerupoutside\");\n          if (e.pointerType === \"touch\") {\n            this.notifyTarget(e, \"touchendoutside\");\n          } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n            this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\");\n          }\n          currentTarget = currentTarget.parent;\n        }\n        delete trackingData.pressTargetsByButton[from.button];\n      }\n      this.freeEvent(e);\n    }\n  }, {\n    key: \"mapWheel\",\n    value: function mapWheel(from) {\n      if (!(from instanceof FederatedWheelEvent.FederatedWheelEvent)) {\n        console.warn(\"EventBoundary cannot map a non-wheel event as a wheel event\");\n        return;\n      }\n      var wheelEvent = this.createWheelEvent(from);\n      this.dispatchEvent(wheelEvent);\n      this.freeEvent(wheelEvent);\n    }\n  }, {\n    key: \"findMountedTarget\",\n    value: function findMountedTarget(propagationPath) {\n      if (!propagationPath) {\n        return null;\n      }\n      var currentTarget = propagationPath[0];\n      for (var i = 1; i < propagationPath.length; i++) {\n        if (propagationPath[i].parent === currentTarget) {\n          currentTarget = propagationPath[i];\n        } else {\n          break;\n        }\n      }\n      return currentTarget;\n    }\n  }, {\n    key: \"createPointerEvent\",\n    value: function createPointerEvent(from, type, target) {\n      var event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);\n      this.copyPointerData(from, event);\n      this.copyMouseData(from, event);\n      this.copyData(from, event);\n      event.nativeEvent = from.nativeEvent;\n      event.originalEvent = from;\n      event.target = target ?? this.hitTest(event.global.x, event.global.y);\n      if (typeof type === \"string\") {\n        event.type = type;\n      }\n      return event;\n    }\n  }, {\n    key: \"createWheelEvent\",\n    value: function createWheelEvent(from) {\n      var event = this.allocateEvent(FederatedWheelEvent.FederatedWheelEvent);\n      this.copyWheelData(from, event);\n      this.copyMouseData(from, event);\n      this.copyData(from, event);\n      event.nativeEvent = from.nativeEvent;\n      event.originalEvent = from;\n      event.target = this.hitTest(event.global.x, event.global.y);\n      return event;\n    }\n  }, {\n    key: \"clonePointerEvent\",\n    value: function clonePointerEvent(from, type) {\n      var event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);\n      event.nativeEvent = from.nativeEvent;\n      event.originalEvent = from.originalEvent;\n      this.copyPointerData(from, event);\n      this.copyMouseData(from, event);\n      this.copyData(from, event);\n      event.target = from.target;\n      event.path = from.composedPath().slice();\n      event.type = type ?? event.type;\n      return event;\n    }\n  }, {\n    key: \"copyWheelData\",\n    value: function copyWheelData(from, to) {\n      to.deltaMode = from.deltaMode;\n      to.deltaX = from.deltaX;\n      to.deltaY = from.deltaY;\n      to.deltaZ = from.deltaZ;\n    }\n  }, {\n    key: \"copyPointerData\",\n    value: function copyPointerData(from, to) {\n      if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent && to instanceof FederatedPointerEvent.FederatedPointerEvent)) return;\n      to.pointerId = from.pointerId;\n      to.width = from.width;\n      to.height = from.height;\n      to.isPrimary = from.isPrimary;\n      to.pointerType = from.pointerType;\n      to.pressure = from.pressure;\n      to.tangentialPressure = from.tangentialPressure;\n      to.tiltX = from.tiltX;\n      to.tiltY = from.tiltY;\n      to.twist = from.twist;\n    }\n  }, {\n    key: \"copyMouseData\",\n    value: function copyMouseData(from, to) {\n      if (!(from instanceof FederatedMouseEvent.FederatedMouseEvent && to instanceof FederatedMouseEvent.FederatedMouseEvent)) return;\n      to.altKey = from.altKey;\n      to.button = from.button;\n      to.buttons = from.buttons;\n      to.client.copyFrom(from.client);\n      to.ctrlKey = from.ctrlKey;\n      to.metaKey = from.metaKey;\n      to.movement.copyFrom(from.movement);\n      to.screen.copyFrom(from.screen);\n      to.global.copyFrom(from.global);\n    }\n  }, {\n    key: \"copyData\",\n    value: function copyData(from, to) {\n      to.isTrusted = from.isTrusted;\n      to.srcElement = from.srcElement;\n      to.timeStamp = performance.now();\n      to.type = from.type;\n      to.detail = from.detail;\n      to.view = from.view;\n      to.which = from.which;\n      to.layer.copyFrom(from.layer);\n      to.page.copyFrom(from.page);\n    }\n  }, {\n    key: \"trackingData\",\n    value: function trackingData(id) {\n      if (!this.mappingState.trackingData[id]) {\n        this.mappingState.trackingData[id] = {\n          pressTargetsByButton: {},\n          clicksByButton: {},\n          overTarget: null\n        };\n      }\n      return this.mappingState.trackingData[id];\n    }\n  }, {\n    key: \"allocateEvent\",\n    value: function allocateEvent(constructor) {\n      if (!this.eventPool.has(constructor)) {\n        this.eventPool.set(constructor, []);\n      }\n      var event = this.eventPool.get(constructor).pop() || new constructor(this);\n      event.eventPhase = event.NONE;\n      event.currentTarget = null;\n      event.path = null;\n      event.target = null;\n      return event;\n    }\n  }, {\n    key: \"freeEvent\",\n    value: function freeEvent(event) {\n      if (event.manager !== this) throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n      var constructor = event.constructor;\n      if (!this.eventPool.has(constructor)) {\n        this.eventPool.set(constructor, []);\n      }\n      this.eventPool.get(constructor).push(event);\n    }\n  }, {\n    key: \"notifyListeners\",\n    value: function notifyListeners(e, type) {\n      var listeners = e.currentTarget._events[type];\n      if (!listeners) return;\n      if (\"fn\" in listeners) {\n        listeners.fn.call(listeners.context, e);\n      } else {\n        for (var i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n          listeners[i].fn.call(listeners[i].context, e);\n        }\n      }\n    }\n  }]);\n  return EventBoundary;\n}();\nexports.EventBoundary = EventBoundary;","map":null,"metadata":{},"sourceType":"script"}