{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport { BatchDrawCall } from './BatchDrawCall.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\nimport { BaseTexture } from '../textures/BaseTexture.mjs';\nimport { ObjectRenderer } from './ObjectRenderer.mjs';\nimport { State } from '../state/State.mjs';\nimport { ViewableBuffer } from '../geometry/ViewableBuffer.mjs';\nimport { BatchShaderGenerator } from './BatchShaderGenerator.mjs';\nimport { checkMaxIfStatementsInShader } from '../shader/utils/checkMaxIfStatementsInShader.mjs';\nimport { settings } from '@pixi/settings';\nimport { premultiplyBlendMode, nextPow2, log2, premultiplyTint } from '@pixi/utils';\nimport { ENV } from '@pixi/constants';\nimport { BatchGeometry } from './BatchGeometry.mjs';\nimport defaultVertex from './texture.mjs';\nimport defaultFragment from './texture2.mjs';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nvar _BatchRenderer = /*#__PURE__*/function (_ObjectRenderer) {\n  _inherits(_BatchRenderer, _ObjectRenderer);\n  function _BatchRenderer(renderer) {\n    var _this;\n    _classCallCheck(this, _BatchRenderer);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_BatchRenderer).call(this, renderer));\n    _this.setShaderGenerator();\n    _this.geometryClass = BatchGeometry;\n    _this.vertexSize = 6;\n    _this.state = State.for2d();\n    _this.size = settings.SPRITE_BATCH_SIZE * 4;\n    _this._vertexCount = 0;\n    _this._indexCount = 0;\n    _this._bufferedElements = [];\n    _this._bufferedTextures = [];\n    _this._bufferSize = 0;\n    _this._shader = null;\n    _this._packedGeometries = [];\n    _this._packedGeometryPoolSize = 2;\n    _this._flushId = 0;\n    _this._aBuffers = {};\n    _this._iBuffers = {};\n    _this.MAX_TEXTURES = 1;\n    _this.renderer.on(\"prerender\", _this.onPrerender, _assertThisInitialized(_assertThisInitialized(_this)));\n    renderer.runners.contextChange.add(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._dcIndex = 0;\n    _this._aIndex = 0;\n    _this._iIndex = 0;\n    _this._attributeBuffer = null;\n    _this._indexBuffer = null;\n    _this._tempBoundTextures = [];\n    return _this;\n  }\n  _createClass(_BatchRenderer, [{\n    key: \"setShaderGenerator\",\n    value: function setShaderGenerator() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$vertex = _ref.vertex,\n        vertex = _ref$vertex === void 0 ? _BatchRenderer.defaultVertexSrc : _ref$vertex,\n        _ref$fragment = _ref.fragment,\n        fragment = _ref$fragment === void 0 ? _BatchRenderer.defaultFragmentTemplate : _ref$fragment;\n      this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n    }\n  }, {\n    key: \"contextChange\",\n    value: function contextChange() {\n      var gl = this.renderer.gl;\n      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {\n        this.MAX_TEXTURES = 1;\n      } else {\n        this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);\n        this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);\n      }\n      this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);\n      for (var i = 0; i < this._packedGeometryPoolSize; i++) {\n        this._packedGeometries[i] = new this.geometryClass();\n      }\n      this.initFlushBuffers();\n    }\n  }, {\n    key: \"initFlushBuffers\",\n    value: function initFlushBuffers() {\n      var _drawCallPool = _BatchRenderer._drawCallPool,\n        _textureArrayPool = _BatchRenderer._textureArrayPool;\n      var MAX_SPRITES = this.size / 4;\n      var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;\n      while (_drawCallPool.length < MAX_SPRITES) {\n        _drawCallPool.push(new BatchDrawCall());\n      }\n      while (_textureArrayPool.length < MAX_TA) {\n        _textureArrayPool.push(new BatchTextureArray());\n      }\n      for (var i = 0; i < this.MAX_TEXTURES; i++) {\n        this._tempBoundTextures[i] = null;\n      }\n    }\n  }, {\n    key: \"onPrerender\",\n    value: function onPrerender() {\n      this._flushId = 0;\n    }\n  }, {\n    key: \"render\",\n    value: function render(element) {\n      if (!element._texture.valid) {\n        return;\n      }\n      if (this._vertexCount + element.vertexData.length / 2 > this.size) {\n        this.flush();\n      }\n      this._vertexCount += element.vertexData.length / 2;\n      this._indexCount += element.indices.length;\n      this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n      this._bufferedElements[this._bufferSize++] = element;\n    }\n  }, {\n    key: \"buildTexturesAndDrawCalls\",\n    value: function buildTexturesAndDrawCalls() {\n      var textures = this._bufferedTextures,\n        MAX_TEXTURES = this.MAX_TEXTURES;\n      var textureArrays = _BatchRenderer._textureArrayPool;\n      var batch = this.renderer.batch;\n      var boundTextures = this._tempBoundTextures;\n      var touch = this.renderer.textureGC.count;\n      var TICK = ++BaseTexture._globalBatch;\n      var countTexArrays = 0;\n      var texArray = textureArrays[0];\n      var start = 0;\n      batch.copyBoundTextures(boundTextures, MAX_TEXTURES);\n      for (var i = 0; i < this._bufferSize; ++i) {\n        var tex = textures[i];\n        textures[i] = null;\n        if (tex._batchEnabled === TICK) {\n          continue;\n        }\n        if (texArray.count >= MAX_TEXTURES) {\n          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);\n          this.buildDrawCalls(texArray, start, i);\n          start = i;\n          texArray = textureArrays[++countTexArrays];\n          ++TICK;\n        }\n        tex._batchEnabled = TICK;\n        tex.touched = touch;\n        texArray.elements[texArray.count++] = tex;\n      }\n      if (texArray.count > 0) {\n        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);\n        this.buildDrawCalls(texArray, start, this._bufferSize);\n        ++countTexArrays;\n        ++TICK;\n      }\n      for (var _i = 0; _i < boundTextures.length; _i++) {\n        boundTextures[_i] = null;\n      }\n      BaseTexture._globalBatch = TICK;\n    }\n  }, {\n    key: \"buildDrawCalls\",\n    value: function buildDrawCalls(texArray, start, finish) {\n      var elements = this._bufferedElements,\n        _attributeBuffer = this._attributeBuffer,\n        _indexBuffer = this._indexBuffer,\n        vertexSize = this.vertexSize;\n      var drawCalls = _BatchRenderer._drawCallPool;\n      var dcIndex = this._dcIndex;\n      var aIndex = this._aIndex;\n      var iIndex = this._iIndex;\n      var drawCall = drawCalls[dcIndex];\n      drawCall.start = this._iIndex;\n      drawCall.texArray = texArray;\n      for (var i = start; i < finish; ++i) {\n        var sprite = elements[i];\n        var tex = sprite._texture.baseTexture;\n        var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];\n        elements[i] = null;\n        if (start < i && drawCall.blend !== spriteBlendMode) {\n          drawCall.size = iIndex - drawCall.start;\n          start = i;\n          drawCall = drawCalls[++dcIndex];\n          drawCall.texArray = texArray;\n          drawCall.start = iIndex;\n        }\n        this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n        aIndex += sprite.vertexData.length / 2 * vertexSize;\n        iIndex += sprite.indices.length;\n        drawCall.blend = spriteBlendMode;\n      }\n      if (start < finish) {\n        drawCall.size = iIndex - drawCall.start;\n        ++dcIndex;\n      }\n      this._dcIndex = dcIndex;\n      this._aIndex = aIndex;\n      this._iIndex = iIndex;\n    }\n  }, {\n    key: \"bindAndClearTexArray\",\n    value: function bindAndClearTexArray(texArray) {\n      var textureSystem = this.renderer.texture;\n      for (var j = 0; j < texArray.count; j++) {\n        textureSystem.bind(texArray.elements[j], texArray.ids[j]);\n        texArray.elements[j] = null;\n      }\n      texArray.count = 0;\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry() {\n      var packedGeometries = this._packedGeometries,\n        attributeBuffer = this._attributeBuffer,\n        indexBuffer = this._indexBuffer;\n      if (!settings.CAN_UPLOAD_SAME_BUFFER) {\n        if (this._packedGeometryPoolSize <= this._flushId) {\n          this._packedGeometryPoolSize++;\n          packedGeometries[this._flushId] = new this.geometryClass();\n        }\n        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n        this.renderer.geometry.bind(packedGeometries[this._flushId]);\n        this.renderer.geometry.updateBuffers();\n        this._flushId++;\n      } else {\n        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n        this.renderer.geometry.updateBuffers();\n      }\n    }\n  }, {\n    key: \"drawBatches\",\n    value: function drawBatches() {\n      var dcCount = this._dcIndex;\n      var _this$renderer = this.renderer,\n        gl = _this$renderer.gl,\n        stateSystem = _this$renderer.state;\n      var drawCalls = _BatchRenderer._drawCallPool;\n      var curTexArray = null;\n      for (var i = 0; i < dcCount; i++) {\n        var _drawCalls$i = drawCalls[i],\n          texArray = _drawCalls$i.texArray,\n          type = _drawCalls$i.type,\n          size = _drawCalls$i.size,\n          start = _drawCalls$i.start,\n          blend = _drawCalls$i.blend;\n        if (curTexArray !== texArray) {\n          curTexArray = texArray;\n          this.bindAndClearTexArray(texArray);\n        }\n        this.state.blendMode = blend;\n        stateSystem.set(this.state);\n        gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this._vertexCount === 0) {\n        return;\n      }\n      this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n      this._indexBuffer = this.getIndexBuffer(this._indexCount);\n      this._aIndex = 0;\n      this._iIndex = 0;\n      this._dcIndex = 0;\n      this.buildTexturesAndDrawCalls();\n      this.updateGeometry();\n      this.drawBatches();\n      this._bufferSize = 0;\n      this._vertexCount = 0;\n      this._indexCount = 0;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.renderer.state.set(this.state);\n      this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);\n      this.renderer.shader.bind(this._shader);\n      if (settings.CAN_UPLOAD_SAME_BUFFER) {\n        this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.flush();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      for (var i = 0; i < this._packedGeometryPoolSize; i++) {\n        if (this._packedGeometries[i]) {\n          this._packedGeometries[i].destroy();\n        }\n      }\n      this.renderer.off(\"prerender\", this.onPrerender, this);\n      this._aBuffers = null;\n      this._iBuffers = null;\n      this._packedGeometries = null;\n      this._attributeBuffer = null;\n      this._indexBuffer = null;\n      if (this._shader) {\n        this._shader.destroy();\n        this._shader = null;\n      }\n      _get(_getPrototypeOf(_BatchRenderer.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"getAttributeBuffer\",\n    value: function getAttributeBuffer(size) {\n      var roundedP2 = nextPow2(Math.ceil(size / 8));\n      var roundedSizeIndex = log2(roundedP2);\n      var roundedSize = roundedP2 * 8;\n      if (this._aBuffers.length <= roundedSizeIndex) {\n        this._iBuffers.length = roundedSizeIndex + 1;\n      }\n      var buffer = this._aBuffers[roundedSize];\n      if (!buffer) {\n        this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n      }\n      return buffer;\n    }\n  }, {\n    key: \"getIndexBuffer\",\n    value: function getIndexBuffer(size) {\n      var roundedP2 = nextPow2(Math.ceil(size / 12));\n      var roundedSizeIndex = log2(roundedP2);\n      var roundedSize = roundedP2 * 12;\n      if (this._iBuffers.length <= roundedSizeIndex) {\n        this._iBuffers.length = roundedSizeIndex + 1;\n      }\n      var buffer = this._iBuffers[roundedSizeIndex];\n      if (!buffer) {\n        this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n      }\n      return buffer;\n    }\n  }, {\n    key: \"packInterleavedGeometry\",\n    value: function packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {\n      var uint32View = attributeBuffer.uint32View,\n        float32View = attributeBuffer.float32View;\n      var packedVertices = aIndex / this.vertexSize;\n      var uvs = element.uvs;\n      var indicies = element.indices;\n      var vertexData = element.vertexData;\n      var textureId = element._texture.baseTexture._batchLocation;\n      var alpha = Math.min(element.worldAlpha, 1);\n      var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);\n      for (var i = 0; i < vertexData.length; i += 2) {\n        float32View[aIndex++] = vertexData[i];\n        float32View[aIndex++] = vertexData[i + 1];\n        float32View[aIndex++] = uvs[i];\n        float32View[aIndex++] = uvs[i + 1];\n        uint32View[aIndex++] = argb;\n        float32View[aIndex++] = textureId;\n      }\n      for (var _i2 = 0; _i2 < indicies.length; _i2++) {\n        indexBuffer[iIndex++] = packedVertices + indicies[_i2];\n      }\n    }\n  }], [{\n    key: \"defaultVertexSrc\",\n    get: function get() {\n      return defaultVertex;\n    }\n  }, {\n    key: \"defaultFragmentTemplate\",\n    get: function get() {\n      return defaultFragment;\n    }\n  }]);\n  return _BatchRenderer;\n}(ObjectRenderer);\nvar BatchRenderer = _BatchRenderer;\nBatchRenderer.extension = {\n  name: \"batch\",\n  type: ExtensionType.RendererPlugin\n};\nBatchRenderer._drawCallPool = [];\nBatchRenderer._textureArrayPool = [];\nextensions.add(BatchRenderer);\nexport { BatchRenderer };","map":null,"metadata":{},"sourceType":"module"}