{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar sprite = require('@pixi/sprite');\nvar core = require('@pixi/core');\nvar _const = require('./const.js');\nvar TextStyle = require('./TextStyle.js');\nvar TextMetrics = require('./TextMetrics.js');\nvar defaultDestroyOptions = {\n  texture: true,\n  children: false,\n  baseTexture: true\n};\nvar _Text = /*#__PURE__*/function (_sprite$Sprite) {\n  _inherits(_Text, _sprite$Sprite);\n  function _Text(text, style, canvas) {\n    var _this;\n    _classCallCheck(this, _Text);\n    var ownCanvas = false;\n    if (!canvas) {\n      canvas = core.settings.ADAPTER.createCanvas();\n      ownCanvas = true;\n    }\n    canvas.width = 3;\n    canvas.height = 3;\n    var texture = core.Texture.from(canvas);\n    texture.orig = new core.Rectangle();\n    texture.trim = new core.Rectangle();\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_Text).call(this, texture));\n    _this._ownCanvas = ownCanvas;\n    _this.canvas = canvas;\n    _this.context = canvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    _this._resolution = core.settings.RESOLUTION;\n    _this._autoResolution = true;\n    _this._text = null;\n    _this._style = null;\n    _this._styleListener = null;\n    _this._font = \"\";\n    _this.text = text;\n    _this.style = style;\n    _this.localStyleID = -1;\n    return _this;\n  }\n  _createClass(_Text, [{\n    key: \"updateText\",\n    value: function updateText(respectDirty) {\n      var style = this._style;\n      if (this.localStyleID !== style.styleID) {\n        this.dirty = true;\n        this.localStyleID = style.styleID;\n      }\n      if (!this.dirty && respectDirty) {\n        return;\n      }\n      this._font = this._style.toFontString();\n      var context = this.context;\n      var measured = TextMetrics.TextMetrics.measureText(this._text || \" \", this._style, this._style.wordWrap, this.canvas);\n      var width = measured.width;\n      var height = measured.height;\n      var lines = measured.lines;\n      var lineHeight = measured.lineHeight;\n      var lineWidths = measured.lineWidths;\n      var maxLineWidth = measured.maxLineWidth;\n      var fontProperties = measured.fontProperties;\n      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);\n      this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);\n      context.scale(this._resolution, this._resolution);\n      context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      context.font = this._font;\n      context.lineWidth = style.strokeThickness;\n      context.textBaseline = style.textBaseline;\n      context.lineJoin = style.lineJoin;\n      context.miterLimit = style.miterLimit;\n      var linePositionX;\n      var linePositionY;\n      var passesCount = style.dropShadow ? 2 : 1;\n      for (var i = 0; i < passesCount; ++i) {\n        var isShadowPass = style.dropShadow && i === 0;\n        var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n        var dsOffsetShadow = dsOffsetText * this._resolution;\n        if (isShadowPass) {\n          context.fillStyle = \"black\";\n          context.strokeStyle = \"black\";\n          var dropShadowColor = style.dropShadowColor;\n          var rgb = core.utils.hex2rgb(typeof dropShadowColor === \"number\" ? dropShadowColor : core.utils.string2hex(dropShadowColor));\n          var dropShadowBlur = style.dropShadowBlur * this._resolution;\n          var dropShadowDistance = style.dropShadowDistance * this._resolution;\n          context.shadowColor = \"rgba(\".concat(rgb[0] * 255, \",\").concat(rgb[1] * 255, \",\").concat(rgb[2] * 255, \",\").concat(style.dropShadowAlpha, \")\");\n          context.shadowBlur = dropShadowBlur;\n          context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n          context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;\n        } else {\n          context.fillStyle = this._generateFillStyle(style, lines, measured);\n          context.strokeStyle = style.stroke;\n          context.shadowColor = \"black\";\n          context.shadowBlur = 0;\n          context.shadowOffsetX = 0;\n          context.shadowOffsetY = 0;\n        }\n        var linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n        if (lineHeight - fontProperties.fontSize < 0) {\n          linePositionYShift = 0;\n        }\n        for (var i2 = 0; i2 < lines.length; i2++) {\n          linePositionX = style.strokeThickness / 2;\n          linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n          if (style.align === \"right\") {\n            linePositionX += maxLineWidth - lineWidths[i2];\n          } else if (style.align === \"center\") {\n            linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n          }\n          if (style.stroke && style.strokeThickness) {\n            this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);\n          }\n          if (style.fill) {\n            this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);\n          }\n        }\n      }\n      this.updateTexture();\n    }\n  }, {\n    key: \"drawLetterSpacing\",\n    value: function drawLetterSpacing(text, x, y) {\n      var isStroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var style = this._style;\n      var letterSpacing = style.letterSpacing;\n      var supportLetterSpacing = _Text.experimentalLetterSpacing && (\"letterSpacing\" in CanvasRenderingContext2D.prototype || \"textLetterSpacing\" in CanvasRenderingContext2D.prototype);\n      if (letterSpacing === 0 || supportLetterSpacing) {\n        if (supportLetterSpacing) {\n          this.context.letterSpacing = letterSpacing;\n          this.context.textLetterSpacing = letterSpacing;\n        }\n        if (isStroke) {\n          this.context.strokeText(text, x, y);\n        } else {\n          this.context.fillText(text, x, y);\n        }\n        return;\n      }\n      var currentPosition = x;\n      var stringArray = Array.from ? Array.from(text) : text.split(\"\");\n      var previousWidth = this.context.measureText(text).width;\n      var currentWidth = 0;\n      for (var i = 0; i < stringArray.length; ++i) {\n        var currentChar = stringArray[i];\n        if (isStroke) {\n          this.context.strokeText(currentChar, currentPosition, y);\n        } else {\n          this.context.fillText(currentChar, currentPosition, y);\n        }\n        var textStr = \"\";\n        for (var j = i + 1; j < stringArray.length; ++j) {\n          textStr += stringArray[j];\n        }\n        currentWidth = this.context.measureText(textStr).width;\n        currentPosition += previousWidth - currentWidth + letterSpacing;\n        previousWidth = currentWidth;\n      }\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture() {\n      var canvas = this.canvas;\n      if (this._style.trim) {\n        var trimmed = core.utils.trimCanvas(canvas);\n        if (trimmed.data) {\n          canvas.width = trimmed.width;\n          canvas.height = trimmed.height;\n          this.context.putImageData(trimmed.data, 0, 0);\n        }\n      }\n      var texture = this._texture;\n      var style = this._style;\n      var padding = style.trim ? 0 : style.padding;\n      var baseTexture = texture.baseTexture;\n      texture.trim.width = texture._frame.width = canvas.width / this._resolution;\n      texture.trim.height = texture._frame.height = canvas.height / this._resolution;\n      texture.trim.x = -padding;\n      texture.trim.y = -padding;\n      texture.orig.width = texture._frame.width - padding * 2;\n      texture.orig.height = texture._frame.height - padding * 2;\n      this._onTextureUpdate();\n      baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);\n      texture.updateUvs();\n      this.dirty = false;\n    }\n  }, {\n    key: \"_render\",\n    value: function _render(renderer) {\n      if (this._autoResolution && this._resolution !== renderer.resolution) {\n        this._resolution = renderer.resolution;\n        this.dirty = true;\n      }\n      this.updateText(true);\n      _get(_getPrototypeOf(_Text.prototype), \"_render\", this).call(this, renderer);\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform() {\n      this.updateText(true);\n      _get(_getPrototypeOf(_Text.prototype), \"updateTransform\", this).call(this);\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(skipUpdate, rect) {\n      this.updateText(true);\n      if (this._textureID === -1) {\n        skipUpdate = false;\n      }\n      return _get(_getPrototypeOf(_Text.prototype), \"getBounds\", this).call(this, skipUpdate, rect);\n    }\n  }, {\n    key: \"getLocalBounds\",\n    value: function getLocalBounds(rect) {\n      this.updateText(true);\n      return _get(_getPrototypeOf(_Text.prototype), \"getLocalBounds\", this).call(this, rect);\n    }\n  }, {\n    key: \"_calculateBounds\",\n    value: function _calculateBounds() {\n      this.calculateVertices();\n      this._bounds.addQuad(this.vertexData);\n    }\n  }, {\n    key: \"_generateFillStyle\",\n    value: function _generateFillStyle(style, lines, metrics) {\n      var fillStyle = style.fill;\n      if (!Array.isArray(fillStyle)) {\n        return fillStyle;\n      } else if (fillStyle.length === 1) {\n        return fillStyle[0];\n      }\n      var gradient;\n      var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;\n      var padding = style.padding || 0;\n      var width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;\n      var height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;\n      var fill = fillStyle.slice();\n      var fillGradientStops = style.fillGradientStops.slice();\n      if (!fillGradientStops.length) {\n        var lengthPlus1 = fill.length + 1;\n        for (var i = 1; i < lengthPlus1; ++i) {\n          fillGradientStops.push(i / lengthPlus1);\n        }\n      }\n      fill.unshift(fillStyle[0]);\n      fillGradientStops.unshift(0);\n      fill.push(fillStyle[fillStyle.length - 1]);\n      fillGradientStops.push(1);\n      if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {\n        gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n        var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n        for (var _i = 0; _i < lines.length; _i++) {\n          var lastLineBottom = metrics.lineHeight * (_i - 1) + textHeight;\n          var thisLineTop = metrics.lineHeight * _i;\n          var thisLineGradientStart = thisLineTop;\n          if (_i > 0 && lastLineBottom > thisLineTop) {\n            thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;\n          }\n          var thisLineBottom = thisLineTop + textHeight;\n          var nextLineTop = metrics.lineHeight * (_i + 1);\n          var thisLineGradientEnd = thisLineBottom;\n          if (_i + 1 < lines.length && nextLineTop < thisLineBottom) {\n            thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;\n          }\n          var gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n          for (var j = 0; j < fill.length; j++) {\n            var lineStop = 0;\n            if (typeof fillGradientStops[j] === \"number\") {\n              lineStop = fillGradientStops[j];\n            } else {\n              lineStop = j / fill.length;\n            }\n            var globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));\n            globalStop = Number(globalStop.toFixed(5));\n            gradient.addColorStop(globalStop, fill[j]);\n          }\n        }\n      } else {\n        gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n        var totalIterations = fill.length + 1;\n        var currentIteration = 1;\n        for (var _i2 = 0; _i2 < fill.length; _i2++) {\n          var stop = void 0;\n          if (typeof fillGradientStops[_i2] === \"number\") {\n            stop = fillGradientStops[_i2];\n          } else {\n            stop = currentIteration / totalIterations;\n          }\n          gradient.addColorStop(stop, fill[_i2]);\n          currentIteration++;\n        }\n      }\n      return gradient;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      if (typeof options === \"boolean\") {\n        options = {\n          children: options\n        };\n      }\n      options = Object.assign({}, defaultDestroyOptions, options);\n      _get(_getPrototypeOf(_Text.prototype), \"destroy\", this).call(this, options);\n      if (this._ownCanvas) {\n        this.canvas.height = this.canvas.width = 0;\n      }\n      this.context = null;\n      this.canvas = null;\n      this._style = null;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      this.updateText(true);\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function set(value) {\n      this.updateText(true);\n      var s = core.utils.sign(this.scale.x) || 1;\n      this.scale.x = s * value / this._texture.orig.width;\n      this._width = value;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      this.updateText(true);\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function set(value) {\n      this.updateText(true);\n      var s = core.utils.sign(this.scale.y) || 1;\n      this.scale.y = s * value / this._texture.orig.height;\n      this._height = value;\n    }\n  }, {\n    key: \"style\",\n    get: function get() {\n      return this._style;\n    },\n    set: function set(style) {\n      style = style || {};\n      if (style instanceof TextStyle.TextStyle) {\n        this._style = style;\n      } else {\n        this._style = new TextStyle.TextStyle(style);\n      }\n      this.localStyleID = -1;\n      this.dirty = true;\n    }\n  }, {\n    key: \"text\",\n    get: function get() {\n      return this._text;\n    },\n    set: function set(text) {\n      text = String(text === null || text === void 0 ? \"\" : text);\n      if (this._text === text) {\n        return;\n      }\n      this._text = text;\n      this.dirty = true;\n    }\n  }, {\n    key: \"resolution\",\n    get: function get() {\n      return this._resolution;\n    },\n    set: function set(value) {\n      this._autoResolution = false;\n      if (this._resolution === value) {\n        return;\n      }\n      this._resolution = value;\n      this.dirty = true;\n    }\n  }]);\n  return _Text;\n}(sprite.Sprite);\nvar Text = _Text;\nText.experimentalLetterSpacing = false;\nexports.Text = Text;","map":null,"metadata":{},"sourceType":"script"}