{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { mapTypeAndFormatToInternalFormat } from './utils/mapTypeAndFormatToInternalFormat.mjs';\nimport { BaseTexture } from './BaseTexture.mjs';\nimport { GLTexture } from './GLTexture.mjs';\nimport { removeItems } from '@pixi/utils';\nimport { SAMPLER_TYPES, TYPES, MIPMAP_MODES, WRAP_MODES, SCALE_MODES } from '@pixi/constants';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nvar TextureSystem = /*#__PURE__*/function () {\n  function TextureSystem(renderer) {\n    _classCallCheck(this, TextureSystem);\n    this.renderer = renderer;\n    this.boundTextures = [];\n    this.currentLocation = -1;\n    this.managedTextures = [];\n    this._unknownBoundTextures = false;\n    this.unknownTexture = new BaseTexture();\n    this.hasIntegerTextures = false;\n  }\n  _createClass(TextureSystem, [{\n    key: \"contextChange\",\n    value: function contextChange() {\n      var gl = this.gl = this.renderer.gl;\n      this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n      this.webGLVersion = this.renderer.context.webGLVersion;\n      this.internalFormats = mapTypeAndFormatToInternalFormat(gl);\n      var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n      this.boundTextures.length = maxTextures;\n      for (var i = 0; i < maxTextures; i++) {\n        this.boundTextures[i] = null;\n      }\n      this.emptyTextures = {};\n      var emptyTexture2D = new GLTexture(gl.createTexture());\n      gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n      this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n      this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());\n      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n      for (var _i = 0; _i < 6; _i++) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      }\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      for (var _i2 = 0; _i2 < this.boundTextures.length; _i2++) {\n        this.bind(null, _i2);\n      }\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(texture) {\n      var location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var gl = this.gl;\n      texture = texture?.castToBaseTexture();\n      if (texture?.valid && !texture.parentTextureArray) {\n        texture.touched = this.renderer.textureGC.count;\n        var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n        if (this.boundTextures[location] !== texture) {\n          if (this.currentLocation !== location) {\n            this.currentLocation = location;\n            gl.activeTexture(gl.TEXTURE0 + location);\n          }\n          gl.bindTexture(texture.target, glTexture.texture);\n        }\n        if (glTexture.dirtyId !== texture.dirtyId) {\n          if (this.currentLocation !== location) {\n            this.currentLocation = location;\n            gl.activeTexture(gl.TEXTURE0 + location);\n          }\n          this.updateTexture(texture);\n        } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {\n          this.updateTextureStyle(texture);\n        }\n        this.boundTextures[location] = texture;\n      } else {\n        if (this.currentLocation !== location) {\n          this.currentLocation = location;\n          gl.activeTexture(gl.TEXTURE0 + location);\n        }\n        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n        this.boundTextures[location] = null;\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._unknownBoundTextures = true;\n      this.hasIntegerTextures = false;\n      this.currentLocation = -1;\n      for (var i = 0; i < this.boundTextures.length; i++) {\n        this.boundTextures[i] = this.unknownTexture;\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind(texture) {\n      var gl = this.gl,\n        boundTextures = this.boundTextures;\n      if (this._unknownBoundTextures) {\n        this._unknownBoundTextures = false;\n        for (var i = 0; i < boundTextures.length; i++) {\n          if (boundTextures[i] === this.unknownTexture) {\n            this.bind(null, i);\n          }\n        }\n      }\n      for (var _i3 = 0; _i3 < boundTextures.length; _i3++) {\n        if (boundTextures[_i3] === texture) {\n          if (this.currentLocation !== _i3) {\n            gl.activeTexture(gl.TEXTURE0 + _i3);\n            this.currentLocation = _i3;\n          }\n          gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n          boundTextures[_i3] = null;\n        }\n      }\n    }\n  }, {\n    key: \"ensureSamplerType\",\n    value: function ensureSamplerType(maxTextures) {\n      var boundTextures = this.boundTextures,\n        hasIntegerTextures = this.hasIntegerTextures,\n        CONTEXT_UID = this.CONTEXT_UID;\n      if (!hasIntegerTextures) {\n        return;\n      }\n      for (var i = maxTextures - 1; i >= 0; --i) {\n        var tex = boundTextures[i];\n        if (tex) {\n          var glTexture = tex._glTextures[CONTEXT_UID];\n          if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {\n            this.renderer.texture.unbind(tex);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"initTexture\",\n    value: function initTexture(texture) {\n      var glTexture = new GLTexture(this.gl.createTexture());\n      glTexture.dirtyId = -1;\n      texture._glTextures[this.CONTEXT_UID] = glTexture;\n      this.managedTextures.push(texture);\n      texture.on(\"dispose\", this.destroyTexture, this);\n      return glTexture;\n    }\n  }, {\n    key: \"initTextureType\",\n    value: function initTextureType(texture, glTexture) {\n      glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;\n      if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT) {\n        glTexture.type = this.gl.HALF_FLOAT;\n      } else {\n        glTexture.type = texture.type;\n      }\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture(texture) {\n      var glTexture = texture._glTextures[this.CONTEXT_UID];\n      if (!glTexture) {\n        return;\n      }\n      var renderer = this.renderer;\n      this.initTextureType(texture, glTexture);\n      if (texture.resource?.upload(renderer, texture, glTexture)) {\n        if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT) {\n          this.hasIntegerTextures = true;\n        }\n      } else {\n        var width = texture.realWidth;\n        var height = texture.realHeight;\n        var gl = renderer.gl;\n        if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {\n          glTexture.width = width;\n          glTexture.height = height;\n          gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);\n        }\n      }\n      if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {\n        this.updateTextureStyle(texture);\n      }\n      glTexture.dirtyId = texture.dirtyId;\n    }\n  }, {\n    key: \"destroyTexture\",\n    value: function destroyTexture(texture, skipRemove) {\n      var gl = this.gl;\n      texture = texture.castToBaseTexture();\n      if (texture._glTextures[this.CONTEXT_UID]) {\n        this.unbind(texture);\n        gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n        texture.off(\"dispose\", this.destroyTexture, this);\n        delete texture._glTextures[this.CONTEXT_UID];\n        if (!skipRemove) {\n          var i = this.managedTextures.indexOf(texture);\n          if (i !== -1) {\n            removeItems(this.managedTextures, i, 1);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"updateTextureStyle\",\n    value: function updateTextureStyle(texture) {\n      var glTexture = texture._glTextures[this.CONTEXT_UID];\n      if (!glTexture) {\n        return;\n      }\n      if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {\n        glTexture.mipmap = false;\n      } else {\n        glTexture.mipmap = texture.mipmap >= 1;\n      }\n      if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {\n        glTexture.wrapMode = WRAP_MODES.CLAMP;\n      } else {\n        glTexture.wrapMode = texture.wrapMode;\n      }\n      if (texture.resource?.style(this.renderer, texture, glTexture)) {} else {\n        this.setStyle(texture, glTexture);\n      }\n      glTexture.dirtyStyleId = texture.dirtyStyleId;\n    }\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(texture, glTexture) {\n      var gl = this.gl;\n      if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL) {\n        gl.generateMipmap(texture.target);\n      }\n      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n      if (glTexture.mipmap) {\n        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n        var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n        if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR) {\n          var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n          gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n        }\n      } else {\n        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n      }\n      gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n    }\n  }]);\n  return TextureSystem;\n}();\nTextureSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"texture\"\n};\nextensions.add(TextureSystem);\nexport { TextureSystem };","map":null,"metadata":{},"sourceType":"module"}