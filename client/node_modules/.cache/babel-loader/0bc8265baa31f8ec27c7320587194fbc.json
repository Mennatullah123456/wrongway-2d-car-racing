{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar display = require('@pixi/display');\nvar tempPoint = new core.Point();\nvar indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\nvar Sprite = /*#__PURE__*/function (_display$Container) {\n  _inherits(Sprite, _display$Container);\n  function Sprite(texture) {\n    var _this;\n    _classCallCheck(this, Sprite);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Sprite).call(this));\n    _this._anchor = new core.ObservablePoint(_this._onAnchorUpdate, _assertThisInitialized(_assertThisInitialized(_this)), texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);\n    _this._texture = null;\n    _this._width = 0;\n    _this._height = 0;\n    _this._tint = null;\n    _this._tintRGB = null;\n    _this.tint = 16777215;\n    _this.blendMode = core.BLEND_MODES.NORMAL;\n    _this._cachedTint = 16777215;\n    _this.uvs = null;\n    _this.texture = texture || core.Texture.EMPTY;\n    _this.vertexData = new Float32Array(8);\n    _this.vertexTrimmedData = null;\n    _this._transformID = -1;\n    _this._textureID = -1;\n    _this._transformTrimmedID = -1;\n    _this._textureTrimmedID = -1;\n    _this.indices = indices;\n    _this.pluginName = \"batch\";\n    _this.isSprite = true;\n    _this._roundPixels = core.settings.ROUND_PIXELS;\n    return _this;\n  }\n  _createClass(Sprite, [{\n    key: \"_onTextureUpdate\",\n    value: function _onTextureUpdate() {\n      this._textureID = -1;\n      this._textureTrimmedID = -1;\n      this._cachedTint = 16777215;\n      if (this._width) {\n        this.scale.x = core.utils.sign(this.scale.x) * this._width / this._texture.orig.width;\n      }\n      if (this._height) {\n        this.scale.y = core.utils.sign(this.scale.y) * this._height / this._texture.orig.height;\n      }\n    }\n  }, {\n    key: \"_onAnchorUpdate\",\n    value: function _onAnchorUpdate() {\n      this._transformID = -1;\n      this._transformTrimmedID = -1;\n    }\n  }, {\n    key: \"calculateVertices\",\n    value: function calculateVertices() {\n      var texture = this._texture;\n      if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {\n        return;\n      }\n      if (this._textureID !== texture._updateID) {\n        this.uvs = this._texture._uvs.uvsFloat32;\n      }\n      this._transformID = this.transform._worldID;\n      this._textureID = texture._updateID;\n      var wt = this.transform.worldTransform;\n      var a = wt.a;\n      var b = wt.b;\n      var c = wt.c;\n      var d = wt.d;\n      var tx = wt.tx;\n      var ty = wt.ty;\n      var vertexData = this.vertexData;\n      var trim = texture.trim;\n      var orig = texture.orig;\n      var anchor = this._anchor;\n      var w0 = 0;\n      var w1 = 0;\n      var h0 = 0;\n      var h1 = 0;\n      if (trim) {\n        w1 = trim.x - anchor._x * orig.width;\n        w0 = w1 + trim.width;\n        h1 = trim.y - anchor._y * orig.height;\n        h0 = h1 + trim.height;\n      } else {\n        w1 = -anchor._x * orig.width;\n        w0 = w1 + orig.width;\n        h1 = -anchor._y * orig.height;\n        h0 = h1 + orig.height;\n      }\n      vertexData[0] = a * w1 + c * h1 + tx;\n      vertexData[1] = d * h1 + b * w1 + ty;\n      vertexData[2] = a * w0 + c * h1 + tx;\n      vertexData[3] = d * h1 + b * w0 + ty;\n      vertexData[4] = a * w0 + c * h0 + tx;\n      vertexData[5] = d * h0 + b * w0 + ty;\n      vertexData[6] = a * w1 + c * h0 + tx;\n      vertexData[7] = d * h0 + b * w1 + ty;\n      if (this._roundPixels) {\n        var resolution = core.settings.RESOLUTION;\n        for (var i = 0; i < vertexData.length; ++i) {\n          vertexData[i] = Math.round(vertexData[i] * resolution) / resolution;\n        }\n      }\n    }\n  }, {\n    key: \"calculateTrimmedVertices\",\n    value: function calculateTrimmedVertices() {\n      if (!this.vertexTrimmedData) {\n        this.vertexTrimmedData = new Float32Array(8);\n      } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {\n        return;\n      }\n      this._transformTrimmedID = this.transform._worldID;\n      this._textureTrimmedID = this._texture._updateID;\n      var texture = this._texture;\n      var vertexData = this.vertexTrimmedData;\n      var orig = texture.orig;\n      var anchor = this._anchor;\n      var wt = this.transform.worldTransform;\n      var a = wt.a;\n      var b = wt.b;\n      var c = wt.c;\n      var d = wt.d;\n      var tx = wt.tx;\n      var ty = wt.ty;\n      var w1 = -anchor._x * orig.width;\n      var w0 = w1 + orig.width;\n      var h1 = -anchor._y * orig.height;\n      var h0 = h1 + orig.height;\n      vertexData[0] = a * w1 + c * h1 + tx;\n      vertexData[1] = d * h1 + b * w1 + ty;\n      vertexData[2] = a * w0 + c * h1 + tx;\n      vertexData[3] = d * h1 + b * w0 + ty;\n      vertexData[4] = a * w0 + c * h0 + tx;\n      vertexData[5] = d * h0 + b * w0 + ty;\n      vertexData[6] = a * w1 + c * h0 + tx;\n      vertexData[7] = d * h0 + b * w1 + ty;\n    }\n  }, {\n    key: \"_render\",\n    value: function _render(renderer) {\n      this.calculateVertices();\n      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n      renderer.plugins[this.pluginName].render(this);\n    }\n  }, {\n    key: \"_calculateBounds\",\n    value: function _calculateBounds() {\n      var trim = this._texture.trim;\n      var orig = this._texture.orig;\n      if (!trim || trim.width === orig.width && trim.height === orig.height) {\n        this.calculateVertices();\n        this._bounds.addQuad(this.vertexData);\n      } else {\n        this.calculateTrimmedVertices();\n        this._bounds.addQuad(this.vertexTrimmedData);\n      }\n    }\n  }, {\n    key: \"getLocalBounds\",\n    value: function getLocalBounds(rect) {\n      if (this.children.length === 0) {\n        if (!this._localBounds) {\n          this._localBounds = new display.Bounds();\n        }\n        this._localBounds.minX = this._texture.orig.width * -this._anchor._x;\n        this._localBounds.minY = this._texture.orig.height * -this._anchor._y;\n        this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);\n        this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);\n        if (!rect) {\n          if (!this._localBoundsRect) {\n            this._localBoundsRect = new core.Rectangle();\n          }\n          rect = this._localBoundsRect;\n        }\n        return this._localBounds.getRectangle(rect);\n      }\n      return _get(_getPrototypeOf(Sprite.prototype), \"getLocalBounds\", this).call(this, rect);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      this.worldTransform.applyInverse(point, tempPoint);\n      var width = this._texture.orig.width;\n      var height = this._texture.orig.height;\n      var x1 = -width * this.anchor.x;\n      var y1 = 0;\n      if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n        y1 = -height * this.anchor.y;\n        if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      _get(_getPrototypeOf(Sprite.prototype), \"destroy\", this).call(this, options);\n      this._texture.off(\"update\", this._onTextureUpdate, this);\n      this._anchor = null;\n      var destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n      if (destroyTexture) {\n        var destroyBaseTexture = typeof options === \"boolean\" ? options : options?.baseTexture;\n        this._texture.destroy(!!destroyBaseTexture);\n      }\n      this._texture = null;\n    }\n  }, {\n    key: \"roundPixels\",\n    set: function set(value) {\n      if (this._roundPixels !== value) {\n        this._transformID = -1;\n      }\n      this._roundPixels = value;\n    },\n    get: function get() {\n      return this._roundPixels;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function set(value) {\n      var s = core.utils.sign(this.scale.x) || 1;\n      this.scale.x = s * value / this._texture.orig.width;\n      this._width = value;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function set(value) {\n      var s = core.utils.sign(this.scale.y) || 1;\n      this.scale.y = s * value / this._texture.orig.height;\n      this._height = value;\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      return this._anchor;\n    },\n    set: function set(value) {\n      this._anchor.copyFrom(value);\n    }\n  }, {\n    key: \"tint\",\n    get: function get() {\n      return this._tint;\n    },\n    set: function set(value) {\n      this._tint = value;\n      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);\n    }\n  }, {\n    key: \"texture\",\n    get: function get() {\n      return this._texture;\n    },\n    set: function set(value) {\n      if (this._texture === value) {\n        return;\n      }\n      if (this._texture) {\n        this._texture.off(\"update\", this._onTextureUpdate, this);\n      }\n      this._texture = value || core.Texture.EMPTY;\n      this._cachedTint = 16777215;\n      this._textureID = -1;\n      this._textureTrimmedID = -1;\n      if (value) {\n        if (value.baseTexture.valid) {\n          this._onTextureUpdate();\n        } else {\n          value.once(\"update\", this._onTextureUpdate, this);\n        }\n      }\n    }\n  }], [{\n    key: \"from\",\n    value: function from(source, options) {\n      var texture = source instanceof core.Texture ? source : core.Texture.from(source, options);\n      return new Sprite(texture);\n    }\n  }]);\n  return Sprite;\n}(display.Container);\nexports.Sprite = Sprite;","map":null,"metadata":{},"sourceType":"script"}