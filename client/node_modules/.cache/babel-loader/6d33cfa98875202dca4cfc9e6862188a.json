{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar mesh = require('@pixi/mesh');\nvar RopeGeometry = /*#__PURE__*/function (_mesh$MeshGeometry) {\n  _inherits(RopeGeometry, _mesh$MeshGeometry);\n  function RopeGeometry() {\n    var _this;\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;\n    var points = arguments.length > 1 ? arguments[1] : undefined;\n    var textureScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _classCallCheck(this, RopeGeometry);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RopeGeometry).call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)));\n    _this.points = points;\n    _this._width = width;\n    _this.textureScale = textureScale;\n    _this.build();\n    return _this;\n  }\n  _createClass(RopeGeometry, [{\n    key: \"build\",\n    value: function build() {\n      var points = this.points;\n      if (!points) return;\n      var vertexBuffer = this.getBuffer(\"aVertexPosition\");\n      var uvBuffer = this.getBuffer(\"aTextureCoord\");\n      var indexBuffer = this.getIndex();\n      if (points.length < 1) {\n        return;\n      }\n      if (vertexBuffer.data.length / 4 !== points.length) {\n        vertexBuffer.data = new Float32Array(points.length * 4);\n        uvBuffer.data = new Float32Array(points.length * 4);\n        indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n      }\n      var uvs = uvBuffer.data;\n      var indices = indexBuffer.data;\n      uvs[0] = 0;\n      uvs[1] = 0;\n      uvs[2] = 0;\n      uvs[3] = 1;\n      var amount = 0;\n      var prev = points[0];\n      var textureWidth = this._width * this.textureScale;\n      var total = points.length;\n      for (var i = 0; i < total; i++) {\n        var index = i * 4;\n        if (this.textureScale > 0) {\n          var dx = prev.x - points[i].x;\n          var dy = prev.y - points[i].y;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          prev = points[i];\n          amount += distance / textureWidth;\n        } else {\n          amount = i / (total - 1);\n        }\n        uvs[index] = amount;\n        uvs[index + 1] = 0;\n        uvs[index + 2] = amount;\n        uvs[index + 3] = 1;\n      }\n      var indexCount = 0;\n      for (var _i = 0; _i < total - 1; _i++) {\n        var _index = _i * 2;\n        indices[indexCount++] = _index;\n        indices[indexCount++] = _index + 1;\n        indices[indexCount++] = _index + 2;\n        indices[indexCount++] = _index + 2;\n        indices[indexCount++] = _index + 1;\n        indices[indexCount++] = _index + 3;\n      }\n      uvBuffer.update();\n      indexBuffer.update();\n      this.updateVertices();\n    }\n  }, {\n    key: \"updateVertices\",\n    value: function updateVertices() {\n      var points = this.points;\n      if (points.length < 1) {\n        return;\n      }\n      var lastPoint = points[0];\n      var nextPoint;\n      var perpX = 0;\n      var perpY = 0;\n      var vertices = this.buffers[0].data;\n      var total = points.length;\n      for (var i = 0; i < total; i++) {\n        var point = points[i];\n        var index = i * 4;\n        if (i < points.length - 1) {\n          nextPoint = points[i + 1];\n        } else {\n          nextPoint = point;\n        }\n        perpY = -(nextPoint.x - lastPoint.x);\n        perpX = nextPoint.y - lastPoint.y;\n        var ratio = (1 - i / (total - 1)) * 10;\n        if (ratio > 1) {\n          ratio = 1;\n        }\n        var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n        var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n        perpX /= perpLength;\n        perpY /= perpLength;\n        perpX *= num;\n        perpY *= num;\n        vertices[index] = point.x + perpX;\n        vertices[index + 1] = point.y + perpY;\n        vertices[index + 2] = point.x - perpX;\n        vertices[index + 3] = point.y - perpY;\n        lastPoint = point;\n      }\n      this.buffers[0].update();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.textureScale > 0) {\n        this.build();\n      } else {\n        this.updateVertices();\n      }\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this._width;\n    }\n  }]);\n  return RopeGeometry;\n}(mesh.MeshGeometry);\nexports.RopeGeometry = RopeGeometry;","map":null,"metadata":{},"sourceType":"script"}