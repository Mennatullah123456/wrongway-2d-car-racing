{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport { DRAW_CALL_POOL, BATCH_POOL, FILL_COMMANDS } from './utils/index.mjs';\nimport { Point, BatchGeometry, WRAP_MODES, BaseTexture, BatchDrawCall, BatchTextureArray, DRAW_MODES, utils } from '@pixi/core';\nimport { GraphicsData } from './GraphicsData.mjs';\nimport { Bounds } from '@pixi/display';\nimport { BatchPart } from './utils/BatchPart.mjs';\nimport { buildPoly } from './utils/buildPoly.mjs';\nimport { buildLine } from './utils/buildLine.mjs';\nvar tmpPoint = new Point();\nvar _GraphicsGeometry = /*#__PURE__*/function (_BatchGeometry) {\n  _inherits(_GraphicsGeometry, _BatchGeometry);\n  function _GraphicsGeometry() {\n    var _this;\n    _classCallCheck(this, _GraphicsGeometry);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_GraphicsGeometry).call(this));\n    _this.closePointEps = 1e-4;\n    _this.boundsPadding = 0;\n    _this.uvsFloat32 = null;\n    _this.indicesUint16 = null;\n    _this.batchable = false;\n    _this.points = [];\n    _this.colors = [];\n    _this.uvs = [];\n    _this.indices = [];\n    _this.textureIds = [];\n    _this.graphicsData = [];\n    _this.drawCalls = [];\n    _this.batchDirty = -1;\n    _this.batches = [];\n    _this.dirty = 0;\n    _this.cacheDirty = -1;\n    _this.clearDirty = 0;\n    _this.shapeIndex = 0;\n    _this._bounds = new Bounds();\n    _this.boundsDirty = -1;\n    return _this;\n  }\n  _createClass(_GraphicsGeometry, [{\n    key: \"invalidate\",\n    value: function invalidate() {\n      this.boundsDirty = -1;\n      this.dirty++;\n      this.batchDirty++;\n      this.shapeIndex = 0;\n      this.points.length = 0;\n      this.colors.length = 0;\n      this.uvs.length = 0;\n      this.indices.length = 0;\n      this.textureIds.length = 0;\n      for (var i = 0; i < this.drawCalls.length; i++) {\n        this.drawCalls[i].texArray.clear();\n        DRAW_CALL_POOL.push(this.drawCalls[i]);\n      }\n      this.drawCalls.length = 0;\n      for (var _i = 0; _i < this.batches.length; _i++) {\n        var batchPart = this.batches[_i];\n        batchPart.reset();\n        BATCH_POOL.push(batchPart);\n      }\n      this.batches.length = 0;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.graphicsData.length > 0) {\n        this.invalidate();\n        this.clearDirty++;\n        this.graphicsData.length = 0;\n      }\n      return this;\n    }\n  }, {\n    key: \"drawShape\",\n    value: function drawShape(shape) {\n      var fillStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var lineStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var matrix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n      this.graphicsData.push(data);\n      this.dirty++;\n      return this;\n    }\n  }, {\n    key: \"drawHole\",\n    value: function drawHole(shape) {\n      var matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (!this.graphicsData.length) {\n        return null;\n      }\n      var data = new GraphicsData(shape, null, null, matrix);\n      var lastShape = this.graphicsData[this.graphicsData.length - 1];\n      data.lineStyle = lastShape.lineStyle;\n      lastShape.holes.push(data);\n      this.dirty++;\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(_GraphicsGeometry.prototype), \"destroy\", this).call(this);\n      for (var i = 0; i < this.graphicsData.length; ++i) {\n        this.graphicsData[i].destroy();\n      }\n      this.points.length = 0;\n      this.points = null;\n      this.colors.length = 0;\n      this.colors = null;\n      this.uvs.length = 0;\n      this.uvs = null;\n      this.indices.length = 0;\n      this.indices = null;\n      this.indexBuffer.destroy();\n      this.indexBuffer = null;\n      this.graphicsData.length = 0;\n      this.graphicsData = null;\n      this.drawCalls.length = 0;\n      this.drawCalls = null;\n      this.batches.length = 0;\n      this.batches = null;\n      this._bounds = null;\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      var graphicsData = this.graphicsData;\n      for (var i = 0; i < graphicsData.length; ++i) {\n        var data = graphicsData[i];\n        if (!data.fillStyle.visible) {\n          continue;\n        }\n        if (data.shape) {\n          if (data.matrix) {\n            data.matrix.applyInverse(point, tmpPoint);\n          } else {\n            tmpPoint.copyFrom(point);\n          }\n          if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n            var hitHole = false;\n            if (data.holes) {\n              for (var i2 = 0; i2 < data.holes.length; i2++) {\n                var hole = data.holes[i2];\n                if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                  hitHole = true;\n                  break;\n                }\n              }\n            }\n            if (!hitHole) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"updateBatches\",\n    value: function updateBatches() {\n      if (!this.graphicsData.length) {\n        this.batchable = true;\n        return;\n      }\n      if (!this.validateBatching()) {\n        return;\n      }\n      this.cacheDirty = this.dirty;\n      var uvs = this.uvs;\n      var graphicsData = this.graphicsData;\n      var batchPart = null;\n      var currentStyle = null;\n      if (this.batches.length > 0) {\n        batchPart = this.batches[this.batches.length - 1];\n        currentStyle = batchPart.style;\n      }\n      for (var i = this.shapeIndex; i < graphicsData.length; i++) {\n        this.shapeIndex++;\n        var data = graphicsData[i];\n        var fillStyle = data.fillStyle;\n        var lineStyle = data.lineStyle;\n        var command = FILL_COMMANDS[data.type];\n        command.build(data);\n        if (data.matrix) {\n          this.transformPoints(data.points, data.matrix);\n        }\n        if (fillStyle.visible || lineStyle.visible) {\n          this.processHoles(data.holes);\n        }\n        for (var j = 0; j < 2; j++) {\n          var style = j === 0 ? fillStyle : lineStyle;\n          if (!style.visible) continue;\n          var nextTexture = style.texture.baseTexture;\n          var index2 = this.indices.length;\n          var attribIndex = this.points.length / 2;\n          nextTexture.wrapMode = WRAP_MODES.REPEAT;\n          if (j === 0) {\n            this.processFill(data);\n          } else {\n            this.processLine(data);\n          }\n          var size = this.points.length / 2 - attribIndex;\n          if (size === 0) continue;\n          if (batchPart && !this._compareStyles(currentStyle, style)) {\n            batchPart.end(index2, attribIndex);\n            batchPart = null;\n          }\n          if (!batchPart) {\n            batchPart = BATCH_POOL.pop() || new BatchPart();\n            batchPart.begin(style, index2, attribIndex);\n            this.batches.push(batchPart);\n            currentStyle = style;\n          }\n          this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n        }\n      }\n      var index = this.indices.length;\n      var attrib = this.points.length / 2;\n      if (batchPart) {\n        batchPart.end(index, attrib);\n      }\n      if (this.batches.length === 0) {\n        this.batchable = true;\n        return;\n      }\n      var need32 = attrib > 65535;\n      if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {\n        this.indicesUint16.set(this.indices);\n      } else {\n        this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n      }\n      this.batchable = this.isBatchable();\n      if (this.batchable) {\n        this.packBatches();\n      } else {\n        this.buildDrawCalls();\n      }\n    }\n  }, {\n    key: \"_compareStyles\",\n    value: function _compareStyles(styleA, styleB) {\n      if (!styleA || !styleB) {\n        return false;\n      }\n      if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n        return false;\n      }\n      if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n        return false;\n      }\n      if (!!styleA.native !== !!styleB.native) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"validateBatching\",\n    value: function validateBatching() {\n      if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n        return false;\n      }\n      for (var i = 0, l = this.graphicsData.length; i < l; i++) {\n        var data = this.graphicsData[i];\n        var fill = data.fillStyle;\n        var line = data.lineStyle;\n        if (fill && !fill.texture.baseTexture.valid) return false;\n        if (line && !line.texture.baseTexture.valid) return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"packBatches\",\n    value: function packBatches() {\n      this.batchDirty++;\n      this.uvsFloat32 = new Float32Array(this.uvs);\n      var batches = this.batches;\n      for (var i = 0, l = batches.length; i < l; i++) {\n        var batch = batches[i];\n        for (var j = 0; j < batch.size; j++) {\n          var index = batch.start + j;\n          this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n        }\n      }\n    }\n  }, {\n    key: \"isBatchable\",\n    value: function isBatchable() {\n      if (this.points.length > 65535 * 2) {\n        return false;\n      }\n      var batches = this.batches;\n      for (var i = 0; i < batches.length; i++) {\n        if (batches[i].style.native) {\n          return false;\n        }\n      }\n      return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;\n    }\n  }, {\n    key: \"buildDrawCalls\",\n    value: function buildDrawCalls() {\n      var TICK = ++BaseTexture._globalBatch;\n      for (var i = 0; i < this.drawCalls.length; i++) {\n        this.drawCalls[i].texArray.clear();\n        DRAW_CALL_POOL.push(this.drawCalls[i]);\n      }\n      this.drawCalls.length = 0;\n      var colors = this.colors;\n      var textureIds = this.textureIds;\n      var currentGroup = DRAW_CALL_POOL.pop();\n      if (!currentGroup) {\n        currentGroup = new BatchDrawCall();\n        currentGroup.texArray = new BatchTextureArray();\n      }\n      currentGroup.texArray.count = 0;\n      currentGroup.start = 0;\n      currentGroup.size = 0;\n      currentGroup.type = DRAW_MODES.TRIANGLES;\n      var textureCount = 0;\n      var currentTexture = null;\n      var textureId = 0;\n      var native = false;\n      var drawMode = DRAW_MODES.TRIANGLES;\n      var index = 0;\n      this.drawCalls.push(currentGroup);\n      for (var _i2 = 0; _i2 < this.batches.length; _i2++) {\n        var data = this.batches[_i2];\n        var MAX_TEXTURES = 8;\n        var style = data.style;\n        var nextTexture = style.texture.baseTexture;\n        if (native !== !!style.native) {\n          native = !!style.native;\n          drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n          currentTexture = null;\n          textureCount = MAX_TEXTURES;\n          TICK++;\n        }\n        if (currentTexture !== nextTexture) {\n          currentTexture = nextTexture;\n          if (nextTexture._batchEnabled !== TICK) {\n            if (textureCount === MAX_TEXTURES) {\n              TICK++;\n              textureCount = 0;\n              if (currentGroup.size > 0) {\n                currentGroup = DRAW_CALL_POOL.pop();\n                if (!currentGroup) {\n                  currentGroup = new BatchDrawCall();\n                  currentGroup.texArray = new BatchTextureArray();\n                }\n                this.drawCalls.push(currentGroup);\n              }\n              currentGroup.start = index;\n              currentGroup.size = 0;\n              currentGroup.texArray.count = 0;\n              currentGroup.type = drawMode;\n            }\n            nextTexture.touched = 1;\n            nextTexture._batchEnabled = TICK;\n            nextTexture._batchLocation = textureCount;\n            nextTexture.wrapMode = WRAP_MODES.REPEAT;\n            currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n            textureCount++;\n          }\n        }\n        currentGroup.size += data.size;\n        index += data.size;\n        textureId = nextTexture._batchLocation;\n        this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n        this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n      }\n      BaseTexture._globalBatch = TICK;\n      this.packAttributes();\n    }\n  }, {\n    key: \"packAttributes\",\n    value: function packAttributes() {\n      var verts = this.points;\n      var uvs = this.uvs;\n      var colors = this.colors;\n      var textureIds = this.textureIds;\n      var glPoints = new ArrayBuffer(verts.length * 3 * 4);\n      var f32 = new Float32Array(glPoints);\n      var u32 = new Uint32Array(glPoints);\n      var p = 0;\n      for (var i = 0; i < verts.length / 2; i++) {\n        f32[p++] = verts[i * 2];\n        f32[p++] = verts[i * 2 + 1];\n        f32[p++] = uvs[i * 2];\n        f32[p++] = uvs[i * 2 + 1];\n        u32[p++] = colors[i];\n        f32[p++] = textureIds[i];\n      }\n      this._buffer.update(glPoints);\n      this._indexBuffer.update(this.indicesUint16);\n    }\n  }, {\n    key: \"processFill\",\n    value: function processFill(data) {\n      if (data.holes.length) {\n        buildPoly.triangulate(data, this);\n      } else {\n        var command = FILL_COMMANDS[data.type];\n        command.triangulate(data, this);\n      }\n    }\n  }, {\n    key: \"processLine\",\n    value: function processLine(data) {\n      buildLine(data, this);\n      for (var i = 0; i < data.holes.length; i++) {\n        buildLine(data.holes[i], this);\n      }\n    }\n  }, {\n    key: \"processHoles\",\n    value: function processHoles(holes) {\n      for (var i = 0; i < holes.length; i++) {\n        var hole = holes[i];\n        var command = FILL_COMMANDS[hole.type];\n        command.build(hole);\n        if (hole.matrix) {\n          this.transformPoints(hole.points, hole.matrix);\n        }\n      }\n    }\n  }, {\n    key: \"calculateBounds\",\n    value: function calculateBounds() {\n      var bounds = this._bounds;\n      bounds.clear();\n      bounds.addVertexData(this.points, 0, this.points.length);\n      bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n  }, {\n    key: \"transformPoints\",\n    value: function transformPoints(points, matrix) {\n      for (var i = 0; i < points.length / 2; i++) {\n        var x = points[i * 2];\n        var y = points[i * 2 + 1];\n        points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n        points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n      }\n    }\n  }, {\n    key: \"addColors\",\n    value: function addColors(colors, color, alpha, size) {\n      var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);\n      var rgba = utils.premultiplyTint(rgb, alpha);\n      colors.length = Math.max(colors.length, offset + size);\n      for (var i = 0; i < size; i++) {\n        colors[offset + i] = rgba;\n      }\n    }\n  }, {\n    key: \"addTextureIds\",\n    value: function addTextureIds(textureIds, id, size) {\n      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      textureIds.length = Math.max(textureIds.length, offset + size);\n      for (var i = 0; i < size; i++) {\n        textureIds[offset + i] = id;\n      }\n    }\n  }, {\n    key: \"addUvs\",\n    value: function addUvs(verts, uvs, texture, start, size) {\n      var matrix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      var index = 0;\n      var uvsStart = uvs.length;\n      var frame = texture.frame;\n      while (index < size) {\n        var x = verts[(start + index) * 2];\n        var y = verts[(start + index) * 2 + 1];\n        if (matrix) {\n          var nx = matrix.a * x + matrix.c * y + matrix.tx;\n          y = matrix.b * x + matrix.d * y + matrix.ty;\n          x = nx;\n        }\n        index++;\n        uvs.push(x / frame.width, y / frame.height);\n      }\n      var baseTexture = texture.baseTexture;\n      if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n        this.adjustUvs(uvs, texture, uvsStart, size);\n      }\n    }\n  }, {\n    key: \"adjustUvs\",\n    value: function adjustUvs(uvs, texture, start, size) {\n      var baseTexture = texture.baseTexture;\n      var eps = 1e-6;\n      var finish = start + size * 2;\n      var frame = texture.frame;\n      var scaleX = frame.width / baseTexture.width;\n      var scaleY = frame.height / baseTexture.height;\n      var offsetX = frame.x / frame.width;\n      var offsetY = frame.y / frame.height;\n      var minX = Math.floor(uvs[start] + eps);\n      var minY = Math.floor(uvs[start + 1] + eps);\n      for (var i = start + 2; i < finish; i += 2) {\n        minX = Math.min(minX, Math.floor(uvs[i] + eps));\n        minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n      }\n      offsetX -= minX;\n      offsetY -= minY;\n      for (var _i3 = start; _i3 < finish; _i3 += 2) {\n        uvs[_i3] = (uvs[_i3] + offsetX) * scaleX;\n        uvs[_i3 + 1] = (uvs[_i3 + 1] + offsetY) * scaleY;\n      }\n    }\n  }, {\n    key: \"bounds\",\n    get: function get() {\n      this.updateBatches();\n      if (this.boundsDirty !== this.dirty) {\n        this.boundsDirty = this.dirty;\n        this.calculateBounds();\n      }\n      return this._bounds;\n    }\n  }]);\n  return _GraphicsGeometry;\n}(BatchGeometry);\nvar GraphicsGeometry = _GraphicsGeometry;\nGraphicsGeometry.BATCHABLE_SIZE = 100;\nexport { GraphicsGeometry };","map":null,"metadata":{},"sourceType":"module"}