{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar contextSettings = {\n  willReadFrequently: true\n};\nvar TextMetrics = /*#__PURE__*/function () {\n  function TextMetrics(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    _classCallCheck(this, TextMetrics);\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  _createClass(TextMetrics, null, [{\n    key: \"measureText\",\n    value: function measureText(text, style, wordWrap) {\n      var canvas = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TextMetrics._canvas;\n      wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;\n      var font = style.toFontString();\n      var fontProperties = TextMetrics.measureFont(font);\n      if (fontProperties.fontSize === 0) {\n        fontProperties.fontSize = style.fontSize;\n        fontProperties.ascent = style.fontSize;\n      }\n      var context = canvas.getContext(\"2d\", contextSettings);\n      context.font = font;\n      var outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;\n      var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n      var lineWidths = new Array(lines.length);\n      var maxLineWidth = 0;\n      for (var i = 0; i < lines.length; i++) {\n        var lineWidth = context.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;\n        lineWidths[i] = lineWidth;\n        maxLineWidth = Math.max(maxLineWidth, lineWidth);\n      }\n      var width = maxLineWidth + style.strokeThickness;\n      if (style.dropShadow) {\n        width += style.dropShadowDistance;\n      }\n      var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n      var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + (lines.length - 1) * (lineHeight + style.leading);\n      if (style.dropShadow) {\n        height += style.dropShadowDistance;\n      }\n      return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);\n    }\n  }, {\n    key: \"wordWrap\",\n    value: function wordWrap(text, style) {\n      var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TextMetrics._canvas;\n      var context = canvas.getContext(\"2d\", contextSettings);\n      var width = 0;\n      var line = \"\";\n      var lines = \"\";\n      var cache = /* @__PURE__ */Object.create(null);\n      var letterSpacing = style.letterSpacing,\n        whiteSpace = style.whiteSpace;\n      var collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);\n      var collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);\n      var canPrependSpaces = !collapseSpaces;\n      var wordWrapWidth = style.wordWrapWidth + letterSpacing;\n      var tokens = TextMetrics.tokenize(text);\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        if (TextMetrics.isNewline(token)) {\n          if (!collapseNewlines) {\n            lines += TextMetrics.addLine(line);\n            canPrependSpaces = !collapseSpaces;\n            line = \"\";\n            width = 0;\n            continue;\n          }\n          token = \" \";\n        }\n        if (collapseSpaces) {\n          var currIsBreakingSpace = TextMetrics.isBreakingSpace(token);\n          var lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);\n          if (currIsBreakingSpace && lastIsBreakingSpace) {\n            continue;\n          }\n        }\n        var tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context);\n        if (tokenWidth > wordWrapWidth) {\n          if (line !== \"\") {\n            lines += TextMetrics.addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          if (TextMetrics.canBreakWords(token, style.breakWords)) {\n            var characters = TextMetrics.wordWrapSplit(token);\n            for (var j = 0; j < characters.length; j++) {\n              var char = characters[j];\n              var k = 1;\n              while (characters[j + k]) {\n                var nextChar = characters[j + k];\n                var lastChar = char[char.length - 1];\n                if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                  char += nextChar;\n                } else {\n                  break;\n                }\n                k++;\n              }\n              j += char.length - 1;\n              var characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context);\n              if (characterWidth + width > wordWrapWidth) {\n                lines += TextMetrics.addLine(line);\n                canPrependSpaces = false;\n                line = \"\";\n                width = 0;\n              }\n              line += char;\n              width += characterWidth;\n            }\n          } else {\n            if (line.length > 0) {\n              lines += TextMetrics.addLine(line);\n              line = \"\";\n              width = 0;\n            }\n            var isLastToken = i === tokens.length - 1;\n            lines += TextMetrics.addLine(token, !isLastToken);\n            canPrependSpaces = false;\n            line = \"\";\n            width = 0;\n          }\n        } else {\n          if (tokenWidth + width > wordWrapWidth) {\n            canPrependSpaces = false;\n            lines += TextMetrics.addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n            line += token;\n            width += tokenWidth;\n          }\n        }\n      }\n      lines += TextMetrics.addLine(line, false);\n      return lines;\n    }\n  }, {\n    key: \"addLine\",\n    value: function addLine(line) {\n      var newLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      line = TextMetrics.trimRight(line);\n      line = newLine ? \"\".concat(line, \"\\n\") : line;\n      return line;\n    }\n  }, {\n    key: \"getFromCache\",\n    value: function getFromCache(key, letterSpacing, cache, context) {\n      var width = cache[key];\n      if (typeof width !== \"number\") {\n        var spacing = key.length * letterSpacing;\n        width = context.measureText(key).width + spacing;\n        cache[key] = width;\n      }\n      return width;\n    }\n  }, {\n    key: \"collapseSpaces\",\n    value: function collapseSpaces(whiteSpace) {\n      return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n    }\n  }, {\n    key: \"collapseNewlines\",\n    value: function collapseNewlines(whiteSpace) {\n      return whiteSpace === \"normal\";\n    }\n  }, {\n    key: \"trimRight\",\n    value: function trimRight(text) {\n      if (typeof text !== \"string\") {\n        return \"\";\n      }\n      for (var i = text.length - 1; i >= 0; i--) {\n        var char = text[i];\n        if (!TextMetrics.isBreakingSpace(char)) {\n          break;\n        }\n        text = text.slice(0, -1);\n      }\n      return text;\n    }\n  }, {\n    key: \"isNewline\",\n    value: function isNewline(char) {\n      if (typeof char !== \"string\") {\n        return false;\n      }\n      return TextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n  }, {\n    key: \"isBreakingSpace\",\n    value: function isBreakingSpace(char, _nextChar) {\n      if (typeof char !== \"string\") {\n        return false;\n      }\n      return TextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n  }, {\n    key: \"tokenize\",\n    value: function tokenize(text) {\n      var tokens = [];\n      var token = \"\";\n      if (typeof text !== \"string\") {\n        return tokens;\n      }\n      for (var i = 0; i < text.length; i++) {\n        var char = text[i];\n        var nextChar = text[i + 1];\n        if (TextMetrics.isBreakingSpace(char, nextChar) || TextMetrics.isNewline(char)) {\n          if (token !== \"\") {\n            tokens.push(token);\n            token = \"\";\n          }\n          tokens.push(char);\n          continue;\n        }\n        token += char;\n      }\n      if (token !== \"\") {\n        tokens.push(token);\n      }\n      return tokens;\n    }\n  }, {\n    key: \"canBreakWords\",\n    value: function canBreakWords(_token, breakWords) {\n      return breakWords;\n    }\n  }, {\n    key: \"canBreakChars\",\n    value: function canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n      return true;\n    }\n  }, {\n    key: \"wordWrapSplit\",\n    value: function wordWrapSplit(token) {\n      return token.split(\"\");\n    }\n  }, {\n    key: \"measureFont\",\n    value: function measureFont(font) {\n      if (TextMetrics._fonts[font]) {\n        return TextMetrics._fonts[font];\n      }\n      var properties = {\n        ascent: 0,\n        descent: 0,\n        fontSize: 0\n      };\n      var canvas = TextMetrics._canvas;\n      var context = TextMetrics._context;\n      context.font = font;\n      var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;\n      var width = Math.ceil(context.measureText(metricsString).width);\n      var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);\n      var height = Math.ceil(TextMetrics.HEIGHT_MULTIPLIER * baseline);\n      baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;\n      canvas.width = width;\n      canvas.height = height;\n      context.fillStyle = \"#f00\";\n      context.fillRect(0, 0, width, height);\n      context.font = font;\n      context.textBaseline = \"alphabetic\";\n      context.fillStyle = \"#000\";\n      context.fillText(metricsString, 0, baseline);\n      var imagedata = context.getImageData(0, 0, width, height).data;\n      var pixels = imagedata.length;\n      var line = width * 4;\n      var i = 0;\n      var idx = 0;\n      var stop = false;\n      for (i = 0; i < baseline; ++i) {\n        for (var j = 0; j < line; j += 4) {\n          if (imagedata[idx + j] !== 255) {\n            stop = true;\n            break;\n          }\n        }\n        if (!stop) {\n          idx += line;\n        } else {\n          break;\n        }\n      }\n      properties.ascent = baseline - i;\n      idx = pixels - line;\n      stop = false;\n      for (i = height; i > baseline; --i) {\n        for (var _j = 0; _j < line; _j += 4) {\n          if (imagedata[idx + _j] !== 255) {\n            stop = true;\n            break;\n          }\n        }\n        if (!stop) {\n          idx -= line;\n        } else {\n          break;\n        }\n      }\n      properties.descent = i - baseline;\n      properties.fontSize = properties.ascent + properties.descent;\n      TextMetrics._fonts[font] = properties;\n      return properties;\n    }\n  }, {\n    key: \"clearMetrics\",\n    value: function clearMetrics() {\n      var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      if (font) {\n        delete TextMetrics._fonts[font];\n      } else {\n        TextMetrics._fonts = {};\n      }\n    }\n  }, {\n    key: \"_canvas\",\n    get: function get() {\n      if (!TextMetrics.__canvas) {\n        var canvas;\n        try {\n          var c = new OffscreenCanvas(0, 0);\n          var context = c.getContext(\"2d\", contextSettings);\n          if (context?.measureText) {\n            TextMetrics.__canvas = c;\n            return c;\n          }\n          canvas = core.settings.ADAPTER.createCanvas();\n        } catch (ex) {\n          canvas = core.settings.ADAPTER.createCanvas();\n        }\n        canvas.width = canvas.height = 10;\n        TextMetrics.__canvas = canvas;\n      }\n      return TextMetrics.__canvas;\n    }\n  }, {\n    key: \"_context\",\n    get: function get() {\n      if (!TextMetrics.__context) {\n        TextMetrics.__context = TextMetrics._canvas.getContext(\"2d\", contextSettings);\n      }\n      return TextMetrics.__context;\n    }\n  }]);\n  return TextMetrics;\n}();\nTextMetrics._fonts = {};\nTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\nTextMetrics.BASELINE_SYMBOL = \"M\";\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics.HEIGHT_MULTIPLIER = 2;\nTextMetrics._newlines = [10, 13];\nTextMetrics._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];\nexports.TextMetrics = TextMetrics;","map":null,"metadata":{},"sourceType":"script"}