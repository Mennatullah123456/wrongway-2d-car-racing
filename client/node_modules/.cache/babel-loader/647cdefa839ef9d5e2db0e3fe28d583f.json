{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar ParticleBuffer = require('./ParticleBuffer.js');\nvar particles$1 = require('./particles.js');\nvar particles = require('./particles2.js');\nvar ParticleRenderer = /*#__PURE__*/function (_core$ObjectRenderer) {\n  _inherits(ParticleRenderer, _core$ObjectRenderer);\n  function ParticleRenderer(renderer) {\n    var _this;\n    _classCallCheck(this, ParticleRenderer);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleRenderer).call(this, renderer));\n    _this.shader = null;\n    _this.properties = null;\n    _this.tempMatrix = new core.Matrix();\n    _this.properties = [{\n      attributeName: \"aVertexPosition\",\n      size: 2,\n      uploadFunction: _this.uploadVertices,\n      offset: 0\n    }, {\n      attributeName: \"aPositionCoord\",\n      size: 2,\n      uploadFunction: _this.uploadPosition,\n      offset: 0\n    }, {\n      attributeName: \"aRotation\",\n      size: 1,\n      uploadFunction: _this.uploadRotation,\n      offset: 0\n    }, {\n      attributeName: \"aTextureCoord\",\n      size: 2,\n      uploadFunction: _this.uploadUvs,\n      offset: 0\n    }, {\n      attributeName: \"aColor\",\n      size: 1,\n      type: core.TYPES.UNSIGNED_BYTE,\n      uploadFunction: _this.uploadTint,\n      offset: 0\n    }];\n    _this.shader = core.Shader.from(particles[\"default\"], particles$1[\"default\"], {});\n    _this.state = core.State.for2d();\n    return _this;\n  }\n  _createClass(ParticleRenderer, [{\n    key: \"render\",\n    value: function render(container) {\n      var children = container.children;\n      var maxSize = container._maxSize;\n      var batchSize = container._batchSize;\n      var renderer = this.renderer;\n      var totalChildren = children.length;\n      if (totalChildren === 0) {\n        return;\n      } else if (totalChildren > maxSize && !container.autoResize) {\n        totalChildren = maxSize;\n      }\n      var buffers = container._buffers;\n      if (!buffers) {\n        buffers = container._buffers = this.generateBuffers(container);\n      }\n      var baseTexture = children[0]._texture.baseTexture;\n      var premultiplied = baseTexture.alphaMode > 0;\n      this.state.blendMode = core.utils.correctBlendMode(container.blendMode, premultiplied);\n      renderer.state.set(this.state);\n      var gl = renderer.gl;\n      var m = container.worldTransform.copyTo(this.tempMatrix);\n      m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n      this.shader.uniforms.translationMatrix = m.toArray(true);\n      this.shader.uniforms.uColor = core.utils.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, premultiplied);\n      this.shader.uniforms.uSampler = baseTexture;\n      this.renderer.shader.bind(this.shader);\n      var updateStatic = false;\n      for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {\n        var amount = totalChildren - i;\n        if (amount > batchSize) {\n          amount = batchSize;\n        }\n        if (j >= buffers.length) {\n          buffers.push(this._generateOneMoreBuffer(container));\n        }\n        var buffer = buffers[j];\n        buffer.uploadDynamic(children, i, amount);\n        var bid = container._bufferUpdateIDs[j] || 0;\n        updateStatic = updateStatic || buffer._updateID < bid;\n        if (updateStatic) {\n          buffer._updateID = container._updateID;\n          buffer.uploadStatic(children, i, amount);\n        }\n        renderer.geometry.bind(buffer.geometry);\n        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n      }\n    }\n  }, {\n    key: \"generateBuffers\",\n    value: function generateBuffers(container) {\n      var buffers = [];\n      var size = container._maxSize;\n      var batchSize = container._batchSize;\n      var dynamicPropertyFlags = container._properties;\n      for (var i = 0; i < size; i += batchSize) {\n        buffers.push(new ParticleBuffer.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n      }\n      return buffers;\n    }\n  }, {\n    key: \"_generateOneMoreBuffer\",\n    value: function _generateOneMoreBuffer(container) {\n      var batchSize = container._batchSize;\n      var dynamicPropertyFlags = container._properties;\n      return new ParticleBuffer.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n    }\n  }, {\n    key: \"uploadVertices\",\n    value: function uploadVertices(children, startIndex, amount, array, stride, offset) {\n      var w0 = 0;\n      var w1 = 0;\n      var h0 = 0;\n      var h1 = 0;\n      for (var i = 0; i < amount; ++i) {\n        var sprite = children[startIndex + i];\n        var texture = sprite._texture;\n        var sx = sprite.scale.x;\n        var sy = sprite.scale.y;\n        var trim = texture.trim;\n        var orig = texture.orig;\n        if (trim) {\n          w1 = trim.x - sprite.anchor.x * orig.width;\n          w0 = w1 + trim.width;\n          h1 = trim.y - sprite.anchor.y * orig.height;\n          h0 = h1 + trim.height;\n        } else {\n          w0 = orig.width * (1 - sprite.anchor.x);\n          w1 = orig.width * -sprite.anchor.x;\n          h0 = orig.height * (1 - sprite.anchor.y);\n          h1 = orig.height * -sprite.anchor.y;\n        }\n        array[offset] = w1 * sx;\n        array[offset + 1] = h1 * sy;\n        array[offset + stride] = w0 * sx;\n        array[offset + stride + 1] = h1 * sy;\n        array[offset + stride * 2] = w0 * sx;\n        array[offset + stride * 2 + 1] = h0 * sy;\n        array[offset + stride * 3] = w1 * sx;\n        array[offset + stride * 3 + 1] = h0 * sy;\n        offset += stride * 4;\n      }\n    }\n  }, {\n    key: \"uploadPosition\",\n    value: function uploadPosition(children, startIndex, amount, array, stride, offset) {\n      for (var i = 0; i < amount; i++) {\n        var spritePosition = children[startIndex + i].position;\n        array[offset] = spritePosition.x;\n        array[offset + 1] = spritePosition.y;\n        array[offset + stride] = spritePosition.x;\n        array[offset + stride + 1] = spritePosition.y;\n        array[offset + stride * 2] = spritePosition.x;\n        array[offset + stride * 2 + 1] = spritePosition.y;\n        array[offset + stride * 3] = spritePosition.x;\n        array[offset + stride * 3 + 1] = spritePosition.y;\n        offset += stride * 4;\n      }\n    }\n  }, {\n    key: \"uploadRotation\",\n    value: function uploadRotation(children, startIndex, amount, array, stride, offset) {\n      for (var i = 0; i < amount; i++) {\n        var spriteRotation = children[startIndex + i].rotation;\n        array[offset] = spriteRotation;\n        array[offset + stride] = spriteRotation;\n        array[offset + stride * 2] = spriteRotation;\n        array[offset + stride * 3] = spriteRotation;\n        offset += stride * 4;\n      }\n    }\n  }, {\n    key: \"uploadUvs\",\n    value: function uploadUvs(children, startIndex, amount, array, stride, offset) {\n      for (var i = 0; i < amount; ++i) {\n        var textureUvs = children[startIndex + i]._texture._uvs;\n        if (textureUvs) {\n          array[offset] = textureUvs.x0;\n          array[offset + 1] = textureUvs.y0;\n          array[offset + stride] = textureUvs.x1;\n          array[offset + stride + 1] = textureUvs.y1;\n          array[offset + stride * 2] = textureUvs.x2;\n          array[offset + stride * 2 + 1] = textureUvs.y2;\n          array[offset + stride * 3] = textureUvs.x3;\n          array[offset + stride * 3 + 1] = textureUvs.y3;\n          offset += stride * 4;\n        } else {\n          array[offset] = 0;\n          array[offset + 1] = 0;\n          array[offset + stride] = 0;\n          array[offset + stride + 1] = 0;\n          array[offset + stride * 2] = 0;\n          array[offset + stride * 2 + 1] = 0;\n          array[offset + stride * 3] = 0;\n          array[offset + stride * 3 + 1] = 0;\n          offset += stride * 4;\n        }\n      }\n    }\n  }, {\n    key: \"uploadTint\",\n    value: function uploadTint(children, startIndex, amount, array, stride, offset) {\n      for (var i = 0; i < amount; ++i) {\n        var sprite = children[startIndex + i];\n        var premultiplied = sprite._texture.baseTexture.alphaMode > 0;\n        var alpha = sprite.alpha;\n        var argb = alpha < 1 && premultiplied ? core.utils.premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n        array[offset] = argb;\n        array[offset + stride] = argb;\n        array[offset + stride * 2] = argb;\n        array[offset + stride * 3] = argb;\n        offset += stride * 4;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(ParticleRenderer.prototype), \"destroy\", this).call(this);\n      if (this.shader) {\n        this.shader.destroy();\n        this.shader = null;\n      }\n      this.tempMatrix = null;\n    }\n  }]);\n  return ParticleRenderer;\n}(core.ObjectRenderer);\nParticleRenderer.extension = {\n  name: \"particle\",\n  type: core.ExtensionType.RendererPlugin\n};\ncore.extensions.add(ParticleRenderer);\nexports.ParticleRenderer = ParticleRenderer;","map":null,"metadata":{},"sourceType":"script"}