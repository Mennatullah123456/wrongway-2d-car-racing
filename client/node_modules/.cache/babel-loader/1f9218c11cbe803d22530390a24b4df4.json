{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport { Rectangle, Point } from '@pixi/math';\nimport { settings } from '@pixi/settings';\nimport { EventEmitter, TextureCache, uid, getResolutionOfUrl } from '@pixi/utils';\nimport { ImageResource } from './resources/ImageResource.mjs';\nimport { BaseTexture } from './BaseTexture.mjs';\nimport { TextureUvs } from './TextureUvs.mjs';\nvar DEFAULT_UVS = new TextureUvs();\nfunction removeAllHandlers(tex) {\n  tex.destroy = function _emptyDestroy() {};\n  tex.on = function _emptyOn() {};\n  tex.once = function _emptyOnce() {};\n  tex.emit = function _emptyEmit() {};\n}\nvar Texture = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Texture, _EventEmitter);\n  function Texture(baseTexture, frame, orig, trim, rotate, anchor) {\n    var _this;\n    _classCallCheck(this, Texture);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Texture).call(this));\n    _this.noFrame = false;\n    if (!frame) {\n      _this.noFrame = true;\n      frame = new Rectangle(0, 0, 1, 1);\n    }\n    if (baseTexture instanceof Texture) {\n      baseTexture = baseTexture.baseTexture;\n    }\n    _this.baseTexture = baseTexture;\n    _this._frame = frame;\n    _this.trim = trim;\n    _this.valid = false;\n    _this._uvs = DEFAULT_UVS;\n    _this.uvMatrix = null;\n    _this.orig = orig || frame;\n    _this._rotate = Number(rotate || 0);\n    if (rotate === true) {\n      _this._rotate = 2;\n    } else if (_this._rotate % 2 !== 0) {\n      throw new Error(\"attempt to use diamond-shaped UVs. If you are sure, set rotation manually\");\n    }\n    _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);\n    _this._updateID = 0;\n    _this.textureCacheIds = [];\n    if (!baseTexture.valid) {\n      baseTexture.once(\"loaded\", _this.onBaseTextureUpdated, _assertThisInitialized(_assertThisInitialized(_this)));\n    } else if (_this.noFrame) {\n      if (baseTexture.valid) {\n        _this.onBaseTextureUpdated(baseTexture);\n      }\n    } else {\n      _this.frame = frame;\n    }\n    if (_this.noFrame) {\n      baseTexture.on(\"update\", _this.onBaseTextureUpdated, _assertThisInitialized(_assertThisInitialized(_this)));\n    }\n    return _this;\n  }\n  _createClass(Texture, [{\n    key: \"update\",\n    value: function update() {\n      if (this.baseTexture.resource) {\n        this.baseTexture.resource.update();\n      }\n    }\n  }, {\n    key: \"onBaseTextureUpdated\",\n    value: function onBaseTextureUpdated(baseTexture) {\n      if (this.noFrame) {\n        if (!this.baseTexture.valid) {\n          return;\n        }\n        this._frame.width = baseTexture.width;\n        this._frame.height = baseTexture.height;\n        this.valid = true;\n        this.updateUvs();\n      } else {\n        this.frame = this._frame;\n      }\n      this.emit(\"update\", this);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(destroyBase) {\n      if (this.baseTexture) {\n        if (destroyBase) {\n          var resource = this.baseTexture.resource;\n          if (resource?.url && TextureCache[resource.url]) {\n            Texture.removeFromCache(resource.url);\n          }\n          this.baseTexture.destroy();\n        }\n        this.baseTexture.off(\"loaded\", this.onBaseTextureUpdated, this);\n        this.baseTexture.off(\"update\", this.onBaseTextureUpdated, this);\n        this.baseTexture = null;\n      }\n      this._frame = null;\n      this._uvs = null;\n      this.trim = null;\n      this.orig = null;\n      this.valid = false;\n      Texture.removeFromCache(this);\n      this.textureCacheIds = null;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clonedFrame = this._frame.clone();\n      var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();\n      var clonedTexture = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim?.clone(), this.rotate, this.defaultAnchor);\n      if (this.noFrame) {\n        clonedTexture._frame = clonedFrame;\n      }\n      return clonedTexture;\n    }\n  }, {\n    key: \"updateUvs\",\n    value: function updateUvs() {\n      if (this._uvs === DEFAULT_UVS) {\n        this._uvs = new TextureUvs();\n      }\n      this._uvs.set(this._frame, this.baseTexture, this.rotate);\n      this._updateID++;\n    }\n  }, {\n    key: \"castToBaseTexture\",\n    value: function castToBaseTexture() {\n      return this.baseTexture;\n    }\n  }, {\n    key: \"resolution\",\n    get: function get() {\n      return this.baseTexture.resolution;\n    }\n  }, {\n    key: \"frame\",\n    get: function get() {\n      return this._frame;\n    },\n    set: function set(frame) {\n      this._frame = frame;\n      this.noFrame = false;\n      var x = frame.x,\n        y = frame.y,\n        width = frame.width,\n        height = frame.height;\n      var xNotFit = x + width > this.baseTexture.width;\n      var yNotFit = y + height > this.baseTexture.height;\n      if (xNotFit || yNotFit) {\n        var relationship = xNotFit && yNotFit ? \"and\" : \"or\";\n        var errorX = \"X: \".concat(x, \" + \").concat(width, \" = \").concat(x + width, \" > \").concat(this.baseTexture.width);\n        var errorY = \"Y: \".concat(y, \" + \").concat(height, \" = \").concat(y + height, \" > \").concat(this.baseTexture.height);\n        throw new Error(\"Texture Error: frame does not fit inside the base Texture dimensions: \".concat(errorX, \" \").concat(relationship, \" \").concat(errorY));\n      }\n      this.valid = width && height && this.baseTexture.valid;\n      if (!this.trim && !this.rotate) {\n        this.orig = frame;\n      }\n      if (this.valid) {\n        this.updateUvs();\n      }\n    }\n  }, {\n    key: \"rotate\",\n    get: function get() {\n      return this._rotate;\n    },\n    set: function set(rotate) {\n      this._rotate = rotate;\n      if (this.valid) {\n        this.updateUvs();\n      }\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.orig.width;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.orig.height;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(source) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : settings.STRICT_TEXTURE_CACHE;\n      var isFrame = typeof source === \"string\";\n      var cacheId = null;\n      if (isFrame) {\n        cacheId = source;\n      } else if (source instanceof BaseTexture) {\n        if (!source.cacheId) {\n          var prefix = options?.pixiIdPrefix || \"pixiid\";\n          source.cacheId = \"\".concat(prefix, \"-\").concat(uid());\n          BaseTexture.addToCache(source, source.cacheId);\n        }\n        cacheId = source.cacheId;\n      } else {\n        if (!source._pixiId) {\n          var _prefix = options?.pixiIdPrefix || \"pixiid\";\n          source._pixiId = \"\".concat(_prefix, \"_\").concat(uid());\n        }\n        cacheId = source._pixiId;\n      }\n      var texture = TextureCache[cacheId];\n      if (isFrame && strict && !texture) {\n        throw new Error(\"The cacheId \\\"\".concat(cacheId, \"\\\" does not exist in TextureCache.\"));\n      }\n      if (!texture && !(source instanceof BaseTexture)) {\n        if (!options.resolution) {\n          options.resolution = getResolutionOfUrl(source);\n        }\n        texture = new Texture(new BaseTexture(source, options));\n        texture.baseTexture.cacheId = cacheId;\n        BaseTexture.addToCache(texture.baseTexture, cacheId);\n        Texture.addToCache(texture, cacheId);\n      } else if (!texture && source instanceof BaseTexture) {\n        texture = new Texture(source);\n        Texture.addToCache(texture, cacheId);\n      }\n      return texture;\n    }\n  }, {\n    key: \"fromURL\",\n    value: function fromURL(url, options) {\n      var resourceOptions = Object.assign({\n        autoLoad: false\n      }, options?.resourceOptions);\n      var texture = Texture.from(url, Object.assign({\n        resourceOptions: resourceOptions\n      }, options), false);\n      var resource = texture.baseTexture.resource;\n      if (texture.baseTexture.valid) {\n        return Promise.resolve(texture);\n      }\n      return resource.load().then(function () {\n        return Promise.resolve(texture);\n      });\n    }\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(buffer, width, height, options) {\n      return new Texture(BaseTexture.fromBuffer(buffer, width, height, options));\n    }\n  }, {\n    key: \"fromLoader\",\n    value: function fromLoader(source, imageUrl, name, options) {\n      var baseTexture = new BaseTexture(source, Object.assign({\n        scaleMode: settings.SCALE_MODE,\n        resolution: getResolutionOfUrl(imageUrl)\n      }, options));\n      var resource = baseTexture.resource;\n      if (resource instanceof ImageResource) {\n        resource.url = imageUrl;\n      }\n      var texture = new Texture(baseTexture);\n      if (!name) {\n        name = imageUrl;\n      }\n      BaseTexture.addToCache(texture.baseTexture, name);\n      Texture.addToCache(texture, name);\n      if (name !== imageUrl) {\n        BaseTexture.addToCache(texture.baseTexture, imageUrl);\n        Texture.addToCache(texture, imageUrl);\n      }\n      if (texture.baseTexture.valid) {\n        return Promise.resolve(texture);\n      }\n      return new Promise(function (resolve) {\n        texture.baseTexture.once(\"loaded\", function () {\n          return resolve(texture);\n        });\n      });\n    }\n  }, {\n    key: \"addToCache\",\n    value: function addToCache(texture, id) {\n      if (id) {\n        if (!texture.textureCacheIds.includes(id)) {\n          texture.textureCacheIds.push(id);\n        }\n        if (TextureCache[id] && TextureCache[id] !== texture) {\n          console.warn(\"Texture added to the cache with an id [\".concat(id, \"] that already had an entry\"));\n        }\n        TextureCache[id] = texture;\n      }\n    }\n  }, {\n    key: \"removeFromCache\",\n    value: function removeFromCache(texture) {\n      if (typeof texture === \"string\") {\n        var textureFromCache = TextureCache[texture];\n        if (textureFromCache) {\n          var index = textureFromCache.textureCacheIds.indexOf(texture);\n          if (index > -1) {\n            textureFromCache.textureCacheIds.splice(index, 1);\n          }\n          delete TextureCache[texture];\n          return textureFromCache;\n        }\n      } else if (texture?.textureCacheIds) {\n        for (var i = 0; i < texture.textureCacheIds.length; ++i) {\n          if (TextureCache[texture.textureCacheIds[i]] === texture) {\n            delete TextureCache[texture.textureCacheIds[i]];\n          }\n        }\n        texture.textureCacheIds.length = 0;\n        return texture;\n      }\n      return null;\n    }\n  }, {\n    key: \"EMPTY\",\n    get: function get() {\n      if (!Texture._EMPTY) {\n        Texture._EMPTY = new Texture(new BaseTexture());\n        removeAllHandlers(Texture._EMPTY);\n        removeAllHandlers(Texture._EMPTY.baseTexture);\n      }\n      return Texture._EMPTY;\n    }\n  }, {\n    key: \"WHITE\",\n    get: function get() {\n      if (!Texture._WHITE) {\n        var canvas = settings.ADAPTER.createCanvas(16, 16);\n        var context = canvas.getContext(\"2d\");\n        canvas.width = 16;\n        canvas.height = 16;\n        context.fillStyle = \"white\";\n        context.fillRect(0, 0, 16, 16);\n        Texture._WHITE = new Texture(BaseTexture.from(canvas));\n        removeAllHandlers(Texture._WHITE);\n        removeAllHandlers(Texture._WHITE.baseTexture);\n      }\n      return Texture._WHITE;\n    }\n  }]);\n  return Texture;\n}(EventEmitter);\nexport { Texture };","map":null,"metadata":{},"sourceType":"module"}