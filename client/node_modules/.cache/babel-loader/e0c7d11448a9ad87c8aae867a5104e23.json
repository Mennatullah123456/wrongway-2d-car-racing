{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar _Spritesheet = /*#__PURE__*/function () {\n  function _Spritesheet(texture, data) {\n    var resolutionFilename = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, _Spritesheet);\n    this.linkedSheets = [];\n    this._texture = texture instanceof core.Texture ? texture : null;\n    this.baseTexture = texture instanceof core.BaseTexture ? texture : this._texture.baseTexture;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    var resource = this.baseTexture.resource;\n    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  _createClass(_Spritesheet, [{\n    key: \"_updateResolution\",\n    value: function _updateResolution() {\n      var resolutionFilename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var scale = this.data.meta.scale;\n      var resolution = core.utils.getResolutionOfUrl(resolutionFilename, null);\n      if (resolution === null) {\n        resolution = parseFloat(scale ?? \"1\");\n      }\n      if (resolution !== 1) {\n        this.baseTexture.setResolution(resolution);\n      }\n      return resolution;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var _this = this;\n      return new Promise(function (resolve) {\n        _this._callback = resolve;\n        _this._batchIndex = 0;\n        if (_this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n          _this._processFrames(0);\n          _this._processAnimations();\n          _this._parseComplete();\n        } else {\n          _this._nextBatch();\n        }\n      });\n    }\n  }, {\n    key: \"_processFrames\",\n    value: function _processFrames(initialFrameIndex) {\n      var frameIndex = initialFrameIndex;\n      var maxFrames = _Spritesheet.BATCH_SIZE;\n      while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n        var i = this._frameKeys[frameIndex];\n        var data = this._frames[i];\n        var rect = data.frame;\n        if (rect) {\n          var frame = null;\n          var trim = null;\n          var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n          var orig = new core.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n          if (data.rotated) {\n            frame = new core.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n          } else {\n            frame = new core.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n          }\n          if (data.trimmed !== false && data.spriteSourceSize) {\n            trim = new core.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n          }\n          this.textures[i] = new core.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);\n          core.Texture.addToCache(this.textures[i], i);\n        }\n        frameIndex++;\n      }\n    }\n  }, {\n    key: \"_processAnimations\",\n    value: function _processAnimations() {\n      var animations = this.data.animations || {};\n      for (var animName in animations) {\n        this.animations[animName] = [];\n        for (var i = 0; i < animations[animName].length; i++) {\n          var frameName = animations[animName][i];\n          this.animations[animName].push(this.textures[frameName]);\n        }\n      }\n    }\n  }, {\n    key: \"_parseComplete\",\n    value: function _parseComplete() {\n      var callback = this._callback;\n      this._callback = null;\n      this._batchIndex = 0;\n      callback.call(this, this.textures);\n    }\n  }, {\n    key: \"_nextBatch\",\n    value: function _nextBatch() {\n      var _this2 = this;\n      this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n      this._batchIndex++;\n      setTimeout(function () {\n        if (_this2._batchIndex * _Spritesheet.BATCH_SIZE < _this2._frameKeys.length) {\n          _this2._nextBatch();\n        } else {\n          _this2._processAnimations();\n          _this2._parseComplete();\n        }\n      }, 0);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var destroyBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      for (var i in this.textures) {\n        this.textures[i].destroy();\n      }\n      this._frames = null;\n      this._frameKeys = null;\n      this.data = null;\n      this.textures = null;\n      if (destroyBase) {\n        this._texture?.destroy();\n        this.baseTexture.destroy();\n      }\n      this._texture = null;\n      this.baseTexture = null;\n      this.linkedSheets = [];\n    }\n  }]);\n  return _Spritesheet;\n}();\nvar Spritesheet = _Spritesheet;\nSpritesheet.BATCH_SIZE = 1e3;\nexports.Spritesheet = Spritesheet;","map":null,"metadata":{},"sourceType":"script"}