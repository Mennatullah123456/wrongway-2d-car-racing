{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar sprite = require('@pixi/sprite');\nvar core = require('@pixi/core');\nvar AnimatedSprite = /*#__PURE__*/function (_sprite$Sprite) {\n  _inherits(AnimatedSprite, _sprite$Sprite);\n  function AnimatedSprite(textures) {\n    var _this;\n    var autoUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    _classCallCheck(this, AnimatedSprite);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AnimatedSprite).call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture));\n    _this._textures = null;\n    _this._durations = null;\n    _this._autoUpdate = autoUpdate;\n    _this._isConnectedToTicker = false;\n    _this.animationSpeed = 1;\n    _this.loop = true;\n    _this.updateAnchor = false;\n    _this.onComplete = null;\n    _this.onFrameChange = null;\n    _this.onLoop = null;\n    _this._currentTime = 0;\n    _this._playing = false;\n    _this._previousFrame = null;\n    _this.textures = textures;\n    return _this;\n  }\n  _createClass(AnimatedSprite, [{\n    key: \"stop\",\n    value: function stop() {\n      if (!this._playing) {\n        return;\n      }\n      this._playing = false;\n      if (this._autoUpdate && this._isConnectedToTicker) {\n        core.Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      }\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this._playing) {\n        return;\n      }\n      this._playing = true;\n      if (this._autoUpdate && !this._isConnectedToTicker) {\n        core.Ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.HIGH);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }, {\n    key: \"gotoAndStop\",\n    value: function gotoAndStop(frameNumber) {\n      this.stop();\n      this.currentFrame = frameNumber;\n    }\n  }, {\n    key: \"gotoAndPlay\",\n    value: function gotoAndPlay(frameNumber) {\n      this.currentFrame = frameNumber;\n      this.play();\n    }\n  }, {\n    key: \"update\",\n    value: function update(deltaTime) {\n      if (!this._playing) {\n        return;\n      }\n      var elapsed = this.animationSpeed * deltaTime;\n      var previousFrame = this.currentFrame;\n      if (this._durations !== null) {\n        var lag = this._currentTime % 1 * this._durations[this.currentFrame];\n        lag += elapsed / 60 * 1e3;\n        while (lag < 0) {\n          this._currentTime--;\n          lag += this._durations[this.currentFrame];\n        }\n        var sign = Math.sign(this.animationSpeed * deltaTime);\n        this._currentTime = Math.floor(this._currentTime);\n        while (lag >= this._durations[this.currentFrame]) {\n          lag -= this._durations[this.currentFrame] * sign;\n          this._currentTime += sign;\n        }\n        this._currentTime += lag / this._durations[this.currentFrame];\n      } else {\n        this._currentTime += elapsed;\n      }\n      if (this._currentTime < 0 && !this.loop) {\n        this.gotoAndStop(0);\n        if (this.onComplete) {\n          this.onComplete();\n        }\n      } else if (this._currentTime >= this._textures.length && !this.loop) {\n        this.gotoAndStop(this._textures.length - 1);\n        if (this.onComplete) {\n          this.onComplete();\n        }\n      } else if (previousFrame !== this.currentFrame) {\n        if (this.loop && this.onLoop) {\n          if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {\n            this.onLoop();\n          } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n            this.onLoop();\n          }\n        }\n        this.updateTexture();\n      }\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture() {\n      var currentFrame = this.currentFrame;\n      if (this._previousFrame === currentFrame) {\n        return;\n      }\n      this._previousFrame = currentFrame;\n      this._texture = this._textures[currentFrame];\n      this._textureID = -1;\n      this._textureTrimmedID = -1;\n      this._cachedTint = 16777215;\n      this.uvs = this._texture._uvs.uvsFloat32;\n      if (this.updateAnchor) {\n        this._anchor.copyFrom(this._texture.defaultAnchor);\n      }\n      if (this.onFrameChange) {\n        this.onFrameChange(this.currentFrame);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      this.stop();\n      _get(_getPrototypeOf(AnimatedSprite.prototype), \"destroy\", this).call(this, options);\n      this.onComplete = null;\n      this.onFrameChange = null;\n      this.onLoop = null;\n    }\n  }, {\n    key: \"totalFrames\",\n    get: function get() {\n      return this._textures.length;\n    }\n  }, {\n    key: \"textures\",\n    get: function get() {\n      return this._textures;\n    },\n    set: function set(value) {\n      if (value[0] instanceof core.Texture) {\n        this._textures = value;\n        this._durations = null;\n      } else {\n        this._textures = [];\n        this._durations = [];\n        for (var i = 0; i < value.length; i++) {\n          this._textures.push(value[i].texture);\n          this._durations.push(value[i].time);\n        }\n      }\n      this._previousFrame = null;\n      this.gotoAndStop(0);\n      this.updateTexture();\n    }\n  }, {\n    key: \"currentFrame\",\n    get: function get() {\n      var currentFrame = Math.floor(this._currentTime) % this._textures.length;\n      if (currentFrame < 0) {\n        currentFrame += this._textures.length;\n      }\n      return currentFrame;\n    },\n    set: function set(value) {\n      if (value < 0 || value > this.totalFrames - 1) {\n        throw new Error(\"[AnimatedSprite]: Invalid frame index value \".concat(value, \", expected to be between 0 and totalFrames \").concat(this.totalFrames, \".\"));\n      }\n      var previousFrame = this.currentFrame;\n      this._currentTime = value;\n      if (previousFrame !== this.currentFrame) {\n        this.updateTexture();\n      }\n    }\n  }, {\n    key: \"playing\",\n    get: function get() {\n      return this._playing;\n    }\n  }, {\n    key: \"autoUpdate\",\n    get: function get() {\n      return this._autoUpdate;\n    },\n    set: function set(value) {\n      if (value !== this._autoUpdate) {\n        this._autoUpdate = value;\n        if (!this._autoUpdate && this._isConnectedToTicker) {\n          core.Ticker.shared.remove(this.update, this);\n          this._isConnectedToTicker = false;\n        } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n          core.Ticker.shared.add(this.update, this);\n          this._isConnectedToTicker = true;\n        }\n      }\n    }\n  }], [{\n    key: \"fromFrames\",\n    value: function fromFrames(frames) {\n      var textures = [];\n      for (var i = 0; i < frames.length; ++i) {\n        textures.push(core.Texture.from(frames[i]));\n      }\n      return new AnimatedSprite(textures);\n    }\n  }, {\n    key: \"fromImages\",\n    value: function fromImages(images) {\n      var textures = [];\n      for (var i = 0; i < images.length; ++i) {\n        textures.push(core.Texture.from(images[i]));\n      }\n      return new AnimatedSprite(textures);\n    }\n  }]);\n  return AnimatedSprite;\n}(sprite.Sprite);\nexports.AnimatedSprite = AnimatedSprite;","map":null,"metadata":{},"sourceType":"script"}