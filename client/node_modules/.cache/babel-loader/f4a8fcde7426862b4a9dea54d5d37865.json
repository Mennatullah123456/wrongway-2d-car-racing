{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\97150\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { RenderTexturePool } from '../renderTexture/RenderTexturePool.mjs';\nimport { Quad } from '../utils/Quad.mjs';\nimport { QuadUv } from '../utils/QuadUv.mjs';\nimport { Point, Matrix, Rectangle } from '@pixi/math';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\nimport { CLEAR_MODES, DRAW_MODES, MSAA_QUALITY } from '@pixi/constants';\nimport { FilterState } from './FilterState.mjs';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nvar tempPoints = [new Point(), new Point(), new Point(), new Point()];\nvar tempMatrix = new Matrix();\nvar FilterSystem = /*#__PURE__*/function () {\n  function FilterSystem(renderer) {\n    _classCallCheck(this, FilterSystem);\n    this.renderer = renderer;\n    this.defaultFilterStack = [{}];\n    this.texturePool = new RenderTexturePool();\n    this.statePool = [];\n    this.quad = new Quad();\n    this.quadUv = new QuadUv();\n    this.tempRect = new Rectangle();\n    this.activeState = {};\n    this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, true);\n    this.forceClear = false;\n    this.useMaxPadding = false;\n  }\n  _createClass(FilterSystem, [{\n    key: \"init\",\n    value: function init() {\n      this.texturePool.setScreenSize(this.renderer.view);\n    }\n  }, {\n    key: \"push\",\n    value: function push(target, filters) {\n      var renderer = this.renderer;\n      var filterStack = this.defaultFilterStack;\n      var state = this.statePool.pop() || new FilterState();\n      var renderTextureSystem = this.renderer.renderTexture;\n      var resolution = filters[0].resolution;\n      var multisample = filters[0].multisample;\n      var padding = filters[0].padding;\n      var autoFit = filters[0].autoFit;\n      var legacy = filters[0].legacy ?? true;\n      for (var i = 1; i < filters.length; i++) {\n        var filter = filters[i];\n        resolution = Math.min(resolution, filter.resolution);\n        multisample = Math.min(multisample, filter.multisample);\n        padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;\n        autoFit = autoFit && filter.autoFit;\n        legacy = legacy || (filter.legacy ?? true);\n      }\n      if (filterStack.length === 1) {\n        this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\n      }\n      filterStack.push(state);\n      state.resolution = resolution;\n      state.multisample = multisample;\n      state.legacy = legacy;\n      state.target = target;\n      state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\n      state.sourceFrame.pad(padding);\n      var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n      if (renderer.projection.transform) {\n        this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);\n      }\n      if (autoFit) {\n        state.sourceFrame.fit(sourceFrameProjected);\n        if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {\n          state.sourceFrame.width = 0;\n          state.sourceFrame.height = 0;\n        }\n      } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {\n        state.sourceFrame.width = 0;\n        state.sourceFrame.height = 0;\n      }\n      this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n      state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);\n      state.filters = filters;\n      state.destinationFrame.width = state.renderTexture.width;\n      state.destinationFrame.height = state.renderTexture.height;\n      var destinationFrame = this.tempRect;\n      destinationFrame.x = 0;\n      destinationFrame.y = 0;\n      destinationFrame.width = state.sourceFrame.width;\n      destinationFrame.height = state.sourceFrame.height;\n      state.renderTexture.filterFrame = state.sourceFrame;\n      state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\n      state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\n      state.transform = renderer.projection.transform;\n      renderer.projection.transform = null;\n      renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\n      renderer.framebuffer.clear(0, 0, 0, 0);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      var filterStack = this.defaultFilterStack;\n      var state = filterStack.pop();\n      var filters = state.filters;\n      this.activeState = state;\n      var globalUniforms = this.globalUniforms.uniforms;\n      globalUniforms.outputFrame = state.sourceFrame;\n      globalUniforms.resolution = state.resolution;\n      var inputSize = globalUniforms.inputSize;\n      var inputPixel = globalUniforms.inputPixel;\n      var inputClamp = globalUniforms.inputClamp;\n      inputSize[0] = state.destinationFrame.width;\n      inputSize[1] = state.destinationFrame.height;\n      inputSize[2] = 1 / inputSize[0];\n      inputSize[3] = 1 / inputSize[1];\n      inputPixel[0] = Math.round(inputSize[0] * state.resolution);\n      inputPixel[1] = Math.round(inputSize[1] * state.resolution);\n      inputPixel[2] = 1 / inputPixel[0];\n      inputPixel[3] = 1 / inputPixel[1];\n      inputClamp[0] = 0.5 * inputPixel[2];\n      inputClamp[1] = 0.5 * inputPixel[3];\n      inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];\n      inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];\n      if (state.legacy) {\n        var filterArea = globalUniforms.filterArea;\n        filterArea[0] = state.destinationFrame.width;\n        filterArea[1] = state.destinationFrame.height;\n        filterArea[2] = state.sourceFrame.x;\n        filterArea[3] = state.sourceFrame.y;\n        globalUniforms.filterClamp = globalUniforms.inputClamp;\n      }\n      this.globalUniforms.update();\n      var lastState = filterStack[filterStack.length - 1];\n      this.renderer.framebuffer.blit();\n      if (filters.length === 1) {\n        filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n        this.returnFilterTexture(state.renderTexture);\n      } else {\n        var flip = state.renderTexture;\n        var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n        flop.filterFrame = flip.filterFrame;\n        var i = 0;\n        for (i = 0; i < filters.length - 1; ++i) {\n          if (i === 1 && state.multisample > 1) {\n            flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n            flop.filterFrame = flip.filterFrame;\n          }\n          filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\n          var t = flip;\n          flip = flop;\n          flop = t;\n        }\n        filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n        if (i > 1 && state.multisample > 1) {\n          this.returnFilterTexture(state.renderTexture);\n        }\n        this.returnFilterTexture(flip);\n        this.returnFilterTexture(flop);\n      }\n      state.clear();\n      this.statePool.push(state);\n    }\n  }, {\n    key: \"bindAndClear\",\n    value: function bindAndClear(filterTexture) {\n      var clearMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CLEAR_MODES.CLEAR;\n      var _this$renderer = this.renderer,\n        renderTextureSystem = _this$renderer.renderTexture,\n        stateSystem = _this$renderer.state;\n      if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n        this.renderer.projection.transform = this.activeState.transform;\n      } else {\n        this.renderer.projection.transform = null;\n      }\n      if (filterTexture?.filterFrame) {\n        var destinationFrame = this.tempRect;\n        destinationFrame.x = 0;\n        destinationFrame.y = 0;\n        destinationFrame.width = filterTexture.filterFrame.width;\n        destinationFrame.height = filterTexture.filterFrame.height;\n        renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n      } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n        renderTextureSystem.bind(filterTexture);\n      } else {\n        this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n      }\n      var autoClear = stateSystem.stateId & 1 || this.forceClear;\n      if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {\n        this.renderer.framebuffer.clear(0, 0, 0, 0);\n      }\n    }\n  }, {\n    key: \"applyFilter\",\n    value: function applyFilter(filter, input, output, clearMode) {\n      var renderer = this.renderer;\n      renderer.state.set(filter.state);\n      this.bindAndClear(output, clearMode);\n      filter.uniforms.uSampler = input;\n      filter.uniforms.filterGlobals = this.globalUniforms;\n      renderer.shader.bind(filter);\n      filter.legacy = !!filter.program.attributeData.aTextureCoord;\n      if (filter.legacy) {\n        this.quadUv.map(input._frame, input.filterFrame);\n        renderer.geometry.bind(this.quadUv);\n        renderer.geometry.draw(DRAW_MODES.TRIANGLES);\n      } else {\n        renderer.geometry.bind(this.quad);\n        renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);\n      }\n    }\n  }, {\n    key: \"calculateSpriteMatrix\",\n    value: function calculateSpriteMatrix(outputMatrix, sprite) {\n      var _this$activeState = this.activeState,\n        sourceFrame = _this$activeState.sourceFrame,\n        destinationFrame = _this$activeState.destinationFrame;\n      var orig = sprite._texture.orig;\n      var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);\n      var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n      worldTransform.invert();\n      mappedMatrix.prepend(worldTransform);\n      mappedMatrix.scale(1 / orig.width, 1 / orig.height);\n      mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n      return mappedMatrix;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n      this.texturePool.clear(false);\n    }\n  }, {\n    key: \"getOptimalFilterTexture\",\n    value: function getOptimalFilterTexture(minWidth, minHeight) {\n      var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var multisample = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MSAA_QUALITY.NONE;\n      return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n    }\n  }, {\n    key: \"getFilterTexture\",\n    value: function getFilterTexture(input, resolution, multisample) {\n      if (typeof input === \"number\") {\n        var swap = input;\n        input = resolution;\n        resolution = swap;\n      }\n      input = input || this.activeState.renderTexture;\n      var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);\n      filterTexture.filterFrame = input.filterFrame;\n      return filterTexture;\n    }\n  }, {\n    key: \"returnFilterTexture\",\n    value: function returnFilterTexture(renderTexture) {\n      this.texturePool.returnTexture(renderTexture);\n    }\n  }, {\n    key: \"emptyPool\",\n    value: function emptyPool() {\n      this.texturePool.clear(true);\n    }\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      this.texturePool.setScreenSize(this.renderer.view);\n    }\n  }, {\n    key: \"transformAABB\",\n    value: function transformAABB(matrix, rect) {\n      var lt = tempPoints[0];\n      var lb = tempPoints[1];\n      var rt = tempPoints[2];\n      var rb = tempPoints[3];\n      lt.set(rect.left, rect.top);\n      lb.set(rect.left, rect.bottom);\n      rt.set(rect.right, rect.top);\n      rb.set(rect.right, rect.bottom);\n      matrix.apply(lt, lt);\n      matrix.apply(lb, lb);\n      matrix.apply(rt, rt);\n      matrix.apply(rb, rb);\n      var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);\n      var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);\n      var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);\n      var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n      rect.x = x0;\n      rect.y = y0;\n      rect.width = x1 - x0;\n      rect.height = y1 - y0;\n    }\n  }, {\n    key: \"roundFrame\",\n    value: function roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n      if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {\n        return;\n      }\n      if (transform) {\n        var _transform = transform,\n          a = _transform.a,\n          b = _transform.b,\n          c = _transform.c,\n          d = _transform.d;\n        if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {\n          return;\n        }\n      }\n      transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n      transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n      this.transformAABB(transform, frame);\n      frame.ceil(resolution);\n      this.transformAABB(transform.invert(), frame);\n    }\n  }]);\n  return FilterSystem;\n}();\nFilterSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"filter\"\n};\nextensions.add(FilterSystem);\nexport { FilterSystem };","map":null,"metadata":{},"sourceType":"module"}